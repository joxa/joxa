;;; The Joxa Compiler
;;; =================
;;; *author: Eric Merritt*
;;; *copyright: Erlware, LLC 2011 - 2012
;;;
;;; This provides the base compiler for the Joxa language. Due to the
;;; way code loading works on the Erlang VM it needs to be all in the
;;; same module, using no macros or external Joxa resources. While
;;; this severely restricts the syntax you can use in the compler, it
;;; does ensure that only a very minimal base language is supported.
(module joxa.compiler
        (require init getopt file
                 lists unicode sets
                 re ets proplists
                 filename ec_dictionary ec_lists
                 filelib file cerl
                 code core_pp compile
                 io io_lib crypto
                 binary gen_server)
        (use (erlang :only (+/2
                            ==/2
                            and/2
                            or/2
                            is_list/1
                            is_binary/1))))

;; defspecs
;; --------
;;
;; Forward declarations for functions that will be defined
;; later. Defspecs serve as descriptions for a function to tools like
;; dialyzer. However, they also serve as forward declarations in the
;; joxa language. In the language, functions have to be defined before
;; they are called. so you end up defining all the dependent functions
;; before you define the function that calls those. For functions that
;; are mutually recursive, this is a a problem. So defspecs serve to
;; document yoru intent to define a function as well as to document
;; the types of that function. of course, if you define a def spec and
;; then do not call it it will result in a compile time error. All the
;; types and specs for the joxa compiler are defined here.

(deftype+ index () {(erlang/non_neg_integer) (erlang/non_neg_integer)})
(deftype path () {(erlang/non_neg_integer) [(erlang/non_neg_integer)]})

(deftype context ()
  {:context,
   (erlang/atom)
   (erlang/list)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)})

(defspec value ((binary) (index)) {:fail (erlang/any)})
(defspec transform-ast ((erlang/any) (erlang/any) (erlang/any))
  {(erlang/any) (erlang/list)})

(defspec make-literal ((path) (context) (erlang/term)) (cerl/cerl))


(defspec idx-from-context ([(erlang/atom)] (path) (context)) {(erlang/non_neg_integer)
                                                              (erlang/non_neg_integer)})

(defspec path? ((path)) (erlang/list))

(defspec get-idx-annots ((path) (erlang/term)) (index))

(defspec comp-use ((index) (context) (erlang/term) (erlang/atom) (erlang/list))
  (context))

(defspec comp-expr ((path) (context) (erlang/term)) {(context) (cerl/cerl)})

(defspec make-pattern-element ((path) (context) [(erlang/term)] (erlang/term))
  {(context) (erlang/term) (cerl/cerl)})

(defspec make-quasi-element ((path) (context) (erlang/term)) {(context) (cerl/cerl)})
(defspec make-quasi ((path) (context) (erlang/term)) {(context) (cerl/cerl)})

(defspec comp-spec-expr ((path) (context) (erlang/term))
  {(context) (erlang/term)})

(defspec make-forms ((path) (context) (erlang/term)) (context))

(defspec traverse-path ((path)) (path))
(defspec incr-path ((path)) (path))
(defspec  get-line-annots ((path) (erlang/term)) (erlang/term))

;; Utilities Used by the Compiler
;; -----------------------------
(defn get-joxa-info (type module fun-name)
  (__try
   (let (info-fun (erlang/make_fun module :--joxa-info 2))
     (info-fun type fun-name))
   (catch (type body)
     (case {type body}
       ({:error :undef}
        :false)
       (_
        (erlang/raise type body (erlang/get_stacktrace)))))))

;; The Compile Context
;; -------------------
;;
;; The context is the heart of the system. It stores all the
;; information about the module undergoing compilation.

;; ### Internal Context Implementation
(defn+ get-context (field ctx)
  (case field
    (:module-name (erlang/element 2 ctx))
    (:annots (erlang/element 3 ctx))
    (:attrs (erlang/element 4 ctx))
    (:exports (erlang/element 5 ctx))
    (:type-exports (erlang/element 6 ctx))
    (:scopes (erlang/element 7 ctx))
    (:type-scopes (erlang/element 8 ctx))
    (:definitions (erlang/element 9 ctx))
    (:types (erlang/element 10 ctx))
    (:aliases (erlang/element 11 ctx))
    (:requires (erlang/element 12 ctx))
    (:uses (erlang/element 13 ctx))
    (:line (erlang/element 14 ctx))
    (:options (erlang/element 15 ctx))
    (:rests (erlang/element 16 ctx))
    (:anon-fun-index (erlang/element 17 ctx))
    (:fun-deps (erlang/element 18 ctx))
    (:macros (erlang/element 19 ctx))
    (:unexported-macros (erlang/element 20 ctx))
    (:warnings (erlang/element 21 ctx))
    (:errors (erlang/element 22 ctx))
    (:binary (erlang/element 23 ctx))
    (_ (erlang/throw {:invalid-field, :context field}))))

(defn+ set-context (field value ctx)
  (case field
    (:module-name (erlang/setelement 2 ctx value))
    (:annots (erlang/setelement 3 ctx value))
    (:attrs (erlang/setelement 4 ctx value))
    (:exports (erlang/setelement 5 ctx value))
    (:type-exports (erlang/setelement 6 ctx value))
    (:scopes (erlang/setelement 7 ctx value))
    (:type-scopes (erlang/setelement 8 ctx value))
    (:definitions (erlang/setelement 9 ctx value))
    (:types (erlang/setelement 10 ctx value))
    (:aliases (erlang/setelement 11 ctx value))
    (:requires (erlang/setelement 12 ctx value))
    (:uses (erlang/setelement 13 ctx value))
    (:line (erlang/setelement 14 ctx value))
    (:options (erlang/setelement 15 ctx value))
    (:rests (erlang/setelement 16 ctx value))
    (:anon-fun-index (erlang/setelement 17 ctx value))
    (:fun-deps (erlang/setelement 18 ctx value))
    (:macros (erlang/setelement 19 ctx value))
    (:unexported-macros (erlang/setelement 20 ctx value))
    (:warnings (erlang/setelement 21 ctx value))
    (:errors (erlang/setelement 22 ctx value))
    (:binary (erlang/setelement 23 ctx value))
    (_ (erlang/throw {:invalid-field, :context field}))))

(defn+ internal-new-context (key-values)
  (lists/foldl (fn (set-val ctx)
                   (case set-val
                     ({field value}
                      (set-context field value ctx))))
               {:context
                :undefined ; module-name
                :undefined ; annots
                []  ; attrs
                (sets/new) ; exports
                (sets/new) ; type-exports
                [] ; scopes
                [] ; type-scopes
                [] ; definitions
                (ec_dictionary/new :ec_dict) ; types
                (ec_dictionary/new :ec_dict) ; alias
                (ec_dictionary/new :ec_dict) ; require
                (ec_dictionary/new :ec_dict) ; use
                :undefined ; line
                [] ; context
                [] ; rest functions
                -1 ; anonymous function index
                (sets/new) ; fun deps
                [] ; macros functions
                [] ; unexported macros
                [] ; warnings
                [] ; Errors
                } key-values))

(defn internal-add-warning (warning ctx)
  (let (warnings (get-context :warnings ctx))
    (set-context :warnings (warning . warnings) ctx)))

(defn internal-add-error (error ctx)
  (let (errors (get-context :errors ctx))
    (set-context :errors (error . errors) ctx)))

(defn internal-erri-from-context (path ctx)
  (__try
   (let (idx (get-idx-annots (path?  path) (get-context :annots ctx))
             filename (ec_dictionary/get :annots (get-context :annots ctx)))
     {filename idx})
   (catch (type body)
     {"" {0 0}})))


(defn internal-add-macro (name arity path ctx)
  (let (macros (get-context :macros ctx))
    (case (lists/any (fn (el)
                         (erlang/== el {name arity})) macros)
      (:true
       (internal-add-error {{:rest-fun-exists name} (internal-erri-from-context path ctx)} ctx))
      (:false
       (set-context :macros ({name arity}  . macros) ctx)))))

(defn internal-add-def (path ctx annots name vars body replace)
  (let (arity (erlang/length vars)
        defs (get-context :definitions ctx)
        fun-deps (get-context :fun-deps ctx)
        cerl-name (cerl/ann_c_fname annots name arity)
        cerl-body (cerl/ann_c_fun annots vars body))

    (case replace
      (:replace
       (case (lists/keymember {name arity} 1 defs)
         (:true
          (set-context :definitions
                       (lists/keyreplace {name arity} 1
                                         defs
                                         {{name arity} {cerl-name cerl-body fun-deps}})
                       ctx))
         (:false
          (set-context :definitions
                       (lists/append defs
                                     [{{name arity} {cerl-name cerl-body fun-deps}}])
                       ctx))))
      (_
       (let (ctx (lists/foldl (fn (el ctx1)
                                    (case el
                                      ({{name arity}, _}
                                       (internal-add-warning
                                        {{:function-exists name arity}
                                         (internal-erri-from-context path ctx1)} ctx1))
                                      (_
                                       ctx1))) ctx defs))
         (set-context :fun-deps (sets/new)
                      (set-context :definitions
                                   (lists/append defs [{{name arity} {cerl-name cerl-body fun-deps}}])
                                   ctx)))))))

(defn internal-rest-remote-reference? (module function possible-arity exports)
  (case (get-joxa-info :rest module function)
    (:false
     :not-a-reference)
    (arity (when (erlang/is_integer arity))
           {:remote :rest {module function arity}})))

(defspec internal-alias? ((erlang/atom) (erlang/atom)
                          (erlang/non_neg_integer) (erlang/term))
  (erlang/term))

(defn internal-remote-function? (module function possible-arity ctx aliased)
  (__try
   (let (requires (get-context :requires ctx)
         exports (ec_dictionary/get module requires))
     (case (internal-rest-remote-reference? module function possible-arity exports)
       (:not-a-reference
        (case (lists/member {function possible-arity} exports)
          (:true
           {:remote :not-rest {module function possible-arity}})
          (:false
           :not-a-reference)))
       (return-val
        return-val)))
   (catch (_type body)
     (case body
       (:not_found
        (case aliased
          (:false
           (internal-alias? module function possible-arity ctx))
          (:true
           :not-a-reference)))))))

(defn internal-remote-function? (module function possible-arity ctx)
  (internal-remote-function? module function possible-arity ctx :false))

(defn internal-alias? (module function possible-arity ctx)
  (__try
   (let (aliases (get-context :aliases ctx)
         aliased-module  (ec_dictionary/get module aliases))
     (internal-remote-function?
      aliased-module function possible-arity ctx :true))
   (catch (type body)
     (case body
       (:not_found
        :not-a-reference)))))

(defn internal-is-local-rest-fun? (name possible-arity ctx)
  (let (rests (get-context :rests ctx))
    (lists/foldl (fn (el acc)
                     (case acc
                       (:false
                        (case el
                          ({name arity} (when (erlang/>= possible-arity arity))
                           {:true arity})
                          (_
                           :false)))
                       (_
                        acc))) :false rests)))

(defn internal-is-speced? (name possible-arity ctx)
  (let (types (get-context :types ctx))
    (case (ec_dictionary/get {name possible-arity} :undefined types)
      (:undefined
       :not-a-reference)
      (_
       {:apply :not-rest {name possible-arity}}))))

(defn internal-rest-used-function? (name uses)
  (lists/foldl (fn (el acc)
                   (case acc
                     (:not-a-reference
                      (case el
                        ({{name _} {real-fun module}}
                         (case (get-joxa-info :rest module real-fun)
                           (:false
                            :not-a-reference)
                           (arity (when (erlang/is_integer arity))
                                  {:remote :rest {module real-fun arity}})))
                        (_
                         :not-a-reference)))
                     (_
                      acc))) :not-a-reference (ec_dictionary/to_list  uses)))

(defn internal-used-function? (name possible-arity ctx)
  (let (uses (get-context :uses ctx))
    (case (internal-rest-used-function? name uses)
      (:not-a-reference
       (case (ec_dictionary/get {name possible-arity} :undefined uses)
         ({fun-name module-name}
          {:remote :not-rest {module-name fun-name possible-arity}})
         (:undefined
          (internal-is-speced? name possible-arity ctx))))
      (result
       result))))

(defn internal-rest-defined-function? (function possible-arity ctx)
  (case (internal-is-local-rest-fun? function possible-arity ctx)
    ({:true arity}
     {:apply :rest {function arity}})
    (x
     :not-a-reference)))

(defn internal-defined-used-function? (name possible-arity ctx)
  (case (internal-rest-defined-function? name possible-arity ctx)
    (:not-a-reference
     (let (defs (get-context :definitions ctx))
       (case (lists/any (fn (el)
                            (case el
                              ({{name possible-arity} _}
                               :true)
                              (_
                               :false)))
                        defs)
         (:true
          {:apply :not-rest {name possible-arity}})
         (:false
          (internal-used-function? name possible-arity ctx)))))
    (rest-apply
     rest-apply)))

(defn internal-resolve-reference (ref arity path ctx)
  (case ref
    ({:--fun _ arity}
     (when (erlang/is_integer arity))
     {ctx (internal-defined-used-function? ref arity ctx)})
    ({:--fun module function}
     (when (and (erlang/is_atom module)
                (erlang/is_atom function)))
     {ctx (internal-remote-function? module function arity ctx)})
    ({:--fun fun invalid-arity}
     {(internal-add-error {{:mismatched-arity fun arity invalid-arity}
                           (internal-erri-from-context path ctx)} ctx)
      :not-a-reference})
    ({:--fun module function arity}
     {ctx (internal-remote-function? module function arity ctx)})
    ({:--fun module function invalid-arity}
     {(internal-add-error {{:mismatched-arity function arity invalid-arity}
                           (internal-erri-from-context path ctx)} ctx)
      :not-a-reference})
    (name
     (when (erlang/is_atom name))
     (let (scopes (get-context :scopes ctx))
       (case (ec_lists/search (fn (scope)
                                  (__try
                                   {:ok (ec_dictionary/get name scope)}
                                   (catch (_type body)
                                     (case body
                                       (:not_found
                                        :not_found))))) scopes)
         ({:ok {var new-arity}  _}
          (when (erlang/or (erlang/== -1 arity)
                           (erlang/== new-arity arity)))
          {ctx {:reference {var new-arity}}})
         (_
          {ctx  (internal-defined-used-function? name arity ctx)}))))
    (_
     {ctx  :not-a-reference})))

(defn get-macro-tag (module function arity)
  (case (get-joxa-info :macro module {function arity})
    (:true
     :macro)
    (:false
     :not-macro)))

(defn+ start-context ()
  (gen_server/start_link :joxa.compiler [] []))

(defn+ start-context (initial-values)
  (gen_server/start_link :joxa.compiler [initial-values] []))

;; ### gen_server callbacks
(defn+ init (args0)
  (case args0
    ([]
     {:ok (internal-new-context '())})
    ([args1]
     {:ok (internal-new-context args1)})))

(defn+ handle_call (request from ctx)
   (let (result
        (case request
          (:annots
           {ctx (get-context :annots ctx)})
          (:anon-fun-index
           {ctx (get-context :anon-fun-index ctx)})
          (:options
           {ctx (get-context :options ctx)})
          (:exports
           {ctx (get-context :exports ctx)})
          (:definitions
           {ctx (get-context :definitions ctx)})
          (:rests
           {ctx (get-context :rests ctx)})
          (:macros
           {ctx (get-context :macros ctx)})
          (:types
           {ctx (get-context :types ctx)})
          (:type-exports
           {ctx (get-context :type-exports ctx)})
          (:unexported-macros
           {ctx (get-context :unexported-macros ctx)})
          (:module-name
           {ctx (get-context :module-name ctx)})
          (:warnings
           {ctx (get-context :warnings ctx)})
          (:errors
           {ctx (get-context :errors ctx)})
          (:line
           {ctx (get-context :line ctx)})
          (:attrs
           {ctx (get-context :attrs ctx)})
          ({:thing-from-context actions path0 do-fun}
           (let (do-action (fn (action path1)
                               (case action
                                 (:traverse
                                  (traverse-path path1))
                                 (:incr
                                  (incr-path path1))))
                           path1     (case actions
                                       (a1 (when (erlang/is_list a1))
                                           (lists/foldl do-action/2 path0 actions))
                                       (a2 (when (erlang/is_atom a2))
                                           (do-action actions path0))))
             {ctx  (do-fun (path? path1) (get-context :annots ctx))}))
          (:warning-count
           {ctx (erlang/length (get-context :warnings ctx))})
          (:error-count
           {ctx (erlang/length (get-context :errors ctx))})
          ({:resolve-reference path ref arity}
           (case (internal-resolve-reference ref arity path ctx)
             ({ctx1 {:remote rest (= mfa {module function rest-arity})}}
              {ctx1 {:remote rest (get-macro-tag module function rest-arity) mfa}})
             ({ctx1  {:apply rest (= fa {function rest-arity})}}
              {ctx1 {:apply rest (get-macro-tag (get-context :module-name ctx)
                                                function rest-arity)
                            fa}})
             (val
              val)))
          ({:resolve-type-reference name arity}
           {ctx (let (type-scopes (get-context :type-scopes ctx)
                             types (get-context :types ctx))
                   (case (lists/any (fn (set-scope)
                                        (sets/is_element {name arity} set-scope)) type-scopes)
                     (:true
                      :true)
                     (:false
                      (case (ec_dictionary/get {name arity} :undefined types)
                        (:undefined
                         :false)
                        (_
                         :true)))))})
          (:get-raw-context
           {ctx ctx})))
     (case result
       ({ctx1 reply}
        {:reply reply ctx1}))))

(defn+ handle_cast (msg ctx)
(case msg
     ({:exports new-exports}
      {:noreply (set-context :exports new-exports ctx)})
     ({:module-name new-module-name}
      {:noreply (set-context :module-name new-module-name ctx)})
     ({:line line-annots}
      {:noreply (set-context :line line-annots ctx)})
     ({:annots annots}
      {:noreply (set-context :annots annots ctx)})
     ({:warning warning}
      {:noreply (internal-add-warning warning ctx)})
     ({:error error}
      {:noreply (internal-add-error error ctx)})
     (:incr-fun-index
      {:noreply (set-context :anon-fun-index (erlang/+ (get-context :anon-fun-index ctx) 1) ctx)})
     ({:add-export fun-name arity annots}
      (let (exports (get-context :exports ctx))
        {:noreply
         (set-context
          :exports (sets/add_element {fun-name arity annots} exports)
          ctx)}))
     ({:add-rest name arity path}
      (let (rests (get-context :rests ctx))
        (case (lists/any (fn (el)
                             (erlang/== el name)) rests)
          (:true
           {:noreply (internal-add-error {{:rest-fun-exists name}
                                          (internal-erri-from-context path ctx)} ctx)})
          (:false
           {:noreply (set-context :rests ({name arity}  . rests) ctx)}))))
     ({:add-macro name arity path}
      {:noreply (internal-add-macro name arity path ctx)})
     ({:add-unexported-macro name arity path}
      (let (unexported-macros (get-context :unexported-macros ctx))
        {:noreply (set-context :unexported-macros ({name arity}  . unexported-macros)
                                        (internal-add-macro name arity path ctx))}))
     ({:add-attr key value}
      (let (attrs (get-context :attrs ctx))
        {:noreply (set-context :attrs ({key value} . attrs) ctx)}))
     ({:add-alias aliased-name module}
      (let (aliases (get-context :aliases ctx))
        {:noreply
         (set-context :aliases
                               (ec_dictionary/add aliased-name module aliases)
                               ctx)}))
     ({:add-require module}
      (let (requires (get-context :requires ctx)
                     exports ((erlang/make_fun module :module_info 1) :exports))
        {:noreply (set-context :requires (ec_dictionary/add module exports requires)
                                        ctx)}))
     ({:add-use alias arity target module}
      (let (use (get-context :uses ctx))
        {:noreply (set-context :uses (ec_dictionary/add {alias arity}
                                                                 {target module} use)
                                        ctx)}))
     ({:add-def path annots name vars body replace}
      {:noreply (internal-add-def path ctx annots name vars body replace)})
     ({:add-fun-dep name arity}
      (let (fun-deps (get-context :fun-deps ctx))
        {:noreply (set-context :fun-deps (sets/add_element {name arity} fun-deps) ctx)}))
     (:push-scope
      (let (scopes (get-context :scopes ctx))
        {:noreply (set-context :scopes ((ec_dictionary/new :ec_dict) . scopes) ctx)}))
     (:pop-scope
      (case (get-context :scopes ctx)
        ((_ . scopes)
         {:noreply (set-context :scopes scopes ctx)})))
     ({:add-reference path name arity cerl-var}
      (let (scopes (get-context :scopes ctx))
        (case scopes
          ((current . rest)
           (case (ec_dictionary/get name :not-in-scope current)
             (:not-in-scope
              {:noreply (set-context :scopes
                                              ((ec_dictionary/add name {cerl-var arity} current) . rest) ctx)})
             (_
              {:noreply (internal-add-error {{:variable-redefinition name}
                                             (internal-erri-from-context path ctx)} ctx)})))
          ([]
           (erlang/throw :no-scope)))))
     (:push-type-scope
      (let (type-scopes (get-context :type-scopes ctx))
        {:noreply (set-context :type-scopes ((sets/new) . type-scopes) ctx)}))
     (:pop-type-scope
      (case (get-context :type-scopes ctx)
        ((_ . scopes)
         {:noreply (set-context :type-scopes scopes ctx)})))
     ({:add-type-reference name arity}
      (case (get-context :type-scopes ctx)
        ((current . scopes)
         {:noreply (set-context :type-scopes ((sets/add_element {name arity} current) . scopes) ctx)})))
     ({:add-type-export name arity}
      (let (type-exports (get-context :type-exports ctx))
        {:noreply (set-context :type-exports (sets/add_element {name arity} type-exports) ctx)}))
     ({:add-type type-name arity body}
      (let (types (get-context :types ctx))
        {:noreply (set-context :types  (ec_dictionary/add {type-name arity}  body types) ctx)}))
     ({:set-context-all args}
      {:noreply (lists/foldl (fn (set-val ctx1)
                                 (case set-val
                                   ({field value}
                                    (set-context field value ctx1))))
                             ctx args)})
     (:stop-context
      {:stop :normal ctx})))

(defn+ handle_info (info state)
  {:noreply state})

(defn+ terminate (reason state)
  :ok)

(defn+ code_change (old-vsn state extra)
  {:ok state})

;; ### Publically Facing Context API
(defn+ start-context (annots module-name)
  (start-context ([(:annots . annots)
                   (:module-name . module-name)])))

(defn+ get-raw-context (ctx)
  (gen_server/call ctx :get-raw-context))

(defn set-context-all-ctx (ctx args)
  (gen_server/cast ctx {:set-context-all args}))

(defn add-warning-ctx (warning ctx)
  (gen_server/cast ctx {:warning warning}))

(defn add-error-ctx (error ctx)
  (gen_server/cast ctx {:error error}))

(defn module-name-ctx (ctx)
  (gen_server/call ctx :module-name))

(defn module-name-ctx (ctx module-name)
  (gen_server/cast ctx {:module-name module-name}))

(defn anon-fun-index-ctx (ctx)
  (gen_server/call ctx :anon-fun-index))

(defn options-ctx (ctx)
  (gen_server/call ctx :options))

(defn exports-ctx (ctx)
  (gen_server/call ctx :exports))

(defn exports-ctx (ctx exports)
  (gen_server/cast ctx {:exports exports}))

(defn definitions-ctx (ctx)
  (gen_server/call ctx :definitions))

(defn rests-ctx (ctx)
  (gen_server/call ctx :rests))

(defn macros-ctx (ctx)
  (gen_server/call ctx :macros))

(defn types-ctx (ctx)
  (gen_server/call ctx :types))

(defn type-exports-ctx (ctx)
  (gen_server/call ctx :type-exports))

(defn unexported-macros-ctx (ctx)
  (gen_server/call ctx :unexported-macros))

(defn warnings-ctx (ctx)
  (gen_server/call ctx :warnings))

(defn errors-ctx (ctx)
  (gen_server/call ctx :errors))

(defn line-ctx (ctx)
  (gen_server/call ctx :line))

(defn line-ctx (ctx line-annots)
  (gen_server/cast ctx {:line line-annots}))

(defn attrs-ctx (ctx)
  (gen_server/call ctx :attrs))

(defn error-count-ctx (ctx)
  (gen_server/call ctx :error-count))

(defn annots-ctx (ctx)
  (gen_server/call ctx :annots))

(defn annots-ctx (ctx annots)
  (gen_server/cast ctx {:annots annots}))

(defn warning-count-ctx (ctx)
  (gen_server/call ctx :warning-count))

(defn incr-fun-index-ctx (ctx)
  (gen_server/cast ctx :incr-fun-index))

(defn+ add-export-ctx (ctx annots fun-name arity)
  (gen_server/cast ctx {:add-export fun-name arity annots}))

(defn add-rest-ctx (path ctx name arity)
  (gen_server/cast ctx {:add-rest name arity path}))

(defn add-macro-ctx (ctx name arity path)
  (gen_server/cast ctx {:add-macro name arity path}))

(defn add-unexported-macro-ctx (path ctx name arity)
  (gen_server/cast ctx {:add-unexported-macro name arity path}))

(defn+ add-attr-ctx (ctx key value)
  (gen_server/cast ctx {:add-attr key value}))

(defn+ add-alias-ctx (ctx aliased-name module)
  (gen_server/cast ctx {:add-alias aliased-name module}))

(defn+ add-require-ctx (ctx module)
  (gen_server/cast ctx {:add-require module}))

(defn+ add-use-ctx (ctx alias arity target module)
  (gen_server/cast ctx {:add-use alias arity target module}))

(defn+ add-def-ctx (path ctx annots name vars body replace)
  (gen_server/cast ctx {:add-def path annots name vars body replace}))

(defn+ add-def-ctx (path ctx annots name vars body)
  (add-def-ctx path ctx annots name vars body :no-replace))

(defn+ add-exported-def-ctx (path ctx annots name vars body replace)
  (let (arity (erlang/length vars))
    (add-export-ctx ctx annots name arity)
    (add-def-ctx path ctx annots name vars body replace)))

(defn+ add-exported-def-ctx (path ctx annots name vars body)
  (add-exported-def-ctx path ctx annots name vars body :no-replace))

(defn add-fun-dep-ctx (ctx name arity)
  (gen_server/cast ctx {:add-fun-dep name arity}))

(defn+ push-scope-ctx (ctx)
  (gen_server/cast ctx :push-scope))

(defn+ pop-scope-ctx (ctx)
  (gen_server/cast ctx :pop-scope))

(defn+ add-reference-to-scope-ctx (path ctx name arity cerl-var)
  (gen_server/cast ctx {:add-reference path name arity cerl-var}))

(defn+ resolve-reference-ctx (path ctx ref possible-arity)
  (gen_server/call ctx {:resolve-reference path ref possible-arity}))

(defn push-type-scope-ctx (ctx)
  (gen_server/cast ctx :push-type-scope))

(defn pop-type-scope-ctx (ctx)
  (gen_server/cast ctx :pop-type-scope))

(defn add-type-reference-to-scope-ctx (ctx name arity)
  (gen_server/cast ctx {:add-type-reference name arity}))

(defn resolve-type-reference-ctx (ctx name arity)
  (gen_server/call ctx {:resolve-type-reference name arity}))

(defn add-type-export-ctx (ctx type-name arity)
  (gen_server/cast ctx {:add-type-export type-name arity}))

(defn add-type-ctx (ctx type-name arity body)
  (gen_server/cast ctx {:add-type type-name arity body}))

(defn+ stop-context (ctx)
  (gen_server/cast ctx :stop-context))

;; The Compiler
;; ------------
;;
;; The parser is complete and now its time to turn our attention to
;; the compiler. we start by defining a compilation context to use for
;; scope management and variable lookup.

;; #### Context Helper Functions
;;
;; These mostly exist to reduce the visual cost of function calls to
;; get values from the annotations.
(defn idx-from-context (actions path0 ctx)
  (gen_server/call ctx {:thing-from-context actions path0 get-idx-annots/2}))

(defn annots-from-context (actions path0 ctx)
  (gen_server/call ctx {:thing-from-context actions path0 get-line-annots/2}))

(defn erri-from-context (actions path0 ctx)
   (let (idx (idx-from-context actions path0 ctx)
         filename (ec_dictionary/get :annots (annots-ctx ctx)))
       {filename idx}))

;; The Lexer and Parser
;; --------------------
;;
;; The parser for Joxa is a [Parsing Expression
;; Grammer](http://en.wikipedia.org/wiki/Parsing_expression_grammar)3
;; based heavily on the Neotoma project. It provides two classes of
;; parse functions. The first set of parse functions are prefixed by a
;; 'p-' and are low level constructor functions that are not part of
;; the Joxa grammer. The second set are parsing functions that are not
;; prefixed with a 'p-' and represent parts of the Joxa grammer it
;; self. These are public because it is expected that they will be
;; used for reader macros.

(defn+ line (index)
  (case index
    ({l _}
     l)))

(defn+ column (index)
  (case index
    ({_  c}
     c)))

(defn+ p-advance-index (matched-input index)
  (case index
    ({ln col}
     (case matched-input
       (mi
        (when (or (is_list mi)
                  (is_binary mi)))
        (lists/foldl p-advance-index/2 index
                     (unicode/characters_to_list mi)))
       (\\n
        {(+ ln 1) 1})
       (_
        {ln (+ col 1)})))))

(defn+ p-charclass (class)
  (case class
    (class (when (erlang/is_list class))
           (p-charclass (erlang/list_to_binary class)))
    (class
     (when (erlang/is_binary class))
     (case (re/compile class  [:unicode :dotall])
       ({:ok re}
        (fn (inp index)
            (case (re/run inp re [:anchored])
              ({:match ({0 length} . _)}
               (case (erlang/split_binary inp length)
                 ({head tail}
                  {head tail (p-advance-index head index)})))
              (_
               {:fail {:expected {:character-class
                                  (erlang/binary_to_list class)} index}}))))))))

(defn+ p-anything ()
  (fn (input index)
      (case input
        (<<>>
         {:fail {:expected :any-character index}})
        (<<(c :utf8) (rest :binary)>>
         {c rest (p-advance-index c index)}))))


(defn+ p-string (s)
  (case s
    (s (when (erlang/is_list s))
       (p-string (erlang/list_to_binary s)))
    (s (when (erlang/is_binary s))
       (let (length (erlang/byte_size s))
         (fn (input index)
             (case input
               (<<(s :size length :binary) (rest :binary)>>
                {s rest (p-advance-index s index)})
               (_
                {:fail {:expected {:string s} index}})))))))

(defn+ p-scan (p inp index acc)
  (case inp
    ([]
     {(lists/reverse acc) [] index})
    (_
     (case (p inp index)
       ({:fail _}
        {(lists/reverse acc) inp index})
       ({result inprem new-index}
        (p-scan p inprem new-index (result . acc)))))))

(defn+ p-one-or-more (p)
  (fn (input index)
      (let (result (p-scan p input index []))
        (case result
          ({(_ . _) _ _}
           result)
          (_
           (case (p input index)
             ({:fail {:expected failure e}}
              {:fail {:expected {:at-least-one failure} index}})))))))

(defn+ p-zero-or-more (p)
  (fn (input index)
      (p-scan p input index [])))

(defn+ p-attempt (in-p input index first-failure)
  (case in-p
    ([]
     first-failure)
    ((p . parsers)
     (case (p input index)
       ((= {:fail _} failure)
        (case first-failure
          (:none
           (p-attempt parsers input index failure))
          (_
           (p-attempt parsers input index first-failure))))
       (result
        result)))))

(defn+ p-choose (parsers)
  (fn (input index)
      (p-attempt parsers input index :none)))

(defn+ p-all (in-p input index acc)
  (case in-p
    ([]
     {(lists/reverse acc) input index})
    ((p . parsers)
     (case (p input index)
       ((= {:fail _} failure)
        failure)
       ({result input-rem new-index}
        (p-all parsers input-rem new-index (result . acc)))))))

(defn+ p-seq (p)
  (fn (input index)
      (p-all p input index [])))

(defn+ p-and (p)
  (fn (input index)
      (p-all p input index [])))

(defn+ p-assert (p)
  (fn (input index)
      (case (p input index)
        ((= {:fail _} failure)
         failure)
        (_
         {[] input index}))))

(defn+ p-not (p)
  (fn (input index)
      (case (p input index)
        ({:fail _}
         {[] input index})
        ({result _ _}
         {:fail {:expected {:no-match result} index}}))))

(defn+ p-optional (p)
  (fn (input index)
      (case (p input index)
        ({:fail _}
         {[] input index})
        ((= {_ _ _} success)
         success))))

(defn+ p-eol ()
  (fn (input index)
      ((p-charclass <<"[\n\r]">>) input index)))

(defn+ p-eof ()
  (fn (input index)
      (case input
        (<<>>
         {:eof <<>> index})
        (_
         {:fail {:expected :eof index}}))))

;; ### Memoization Support Functions
;;
;; The following functions support memoization of for the parser. This
;; is critically important to getting any kind of reasonable speed at
;; all out of the parser.
(definline memo-table-name ()
  (erlang/get :parse-memo-table))

(definline get-memo (index name)
  (case (ets/lookup (memo-table-name) index)
    ([]
     {:error :not-found})
    ([{index plist}]
     (case (proplists/lookup name plist)
       ({name result}
        {:ok result})
       (_
        {:error :not-found})))))

(definline memoize (index name result)
  (let (memo (case (ets/lookup (memo-table-name) index)
               ([]
                [])
               ([{index plist}]
                plist)))
    (ets/insert (memo-table-name) {index ({name result} . memo)})))

(defn+ release-memo ()
  (ets/delete (memo-table-name)))

(defn+ setup-memo ()
  (erlang/put :parse-memo-table (ets/new :joxa.compiler [:set])))

(defn+ p (inp start-index name parse-fun transform-fun)
  (case (get-memo start-index name)
    ({:ok memo}
     memo)
    (_
     (let (result (case (parse-fun inp start-index)
                    ((= {:fail _} failure)
                     failure)
                    ({match inp-rem new-index}
                     {(transform-fun match start-index)
                      inp-rem new-index})))
       (memoize start-index name result)
       result))))

(defn+ p (inp start-index name parse-fun)
  (p inp start-index name parse-fun (fn (n idx) n)))

;; ### Joxa Grammer Lexer
;;
;; The following functions represent the grammer of Joxa and can be
;; built on and used by reader macros.
(defn+ space (input index)
  (p input index :space
     (p-charclass <<"[ \t\n\s\r]">>)))

(defn+ comment (input index)
  (p input index :comment
     (p-seq [(p-string <<";">>)
             (p-zero-or-more (p-charclass <<"[^\n\r]">>))
             (p-choose [(p-eol)
                        (p-eof)])])))

(defn+ ignorable (input index)
  (p input index :ignorable
     (p-optional (p-zero-or-more (p-choose [space/2
                                            (p-string <<",">>)
                                            comment/2])))
     (fn (node idx)
         [])))

(defn+ digit (input index)
  (p input index :digit
     (p-charclass <<"[0-9]">>)))

(defn+ int-part (input index)
  (p input index :int-part
     (p-seq [(p-optional (p-string <<"-">>)),
             (p-one-or-more digit/2)])))

(defn+ frac-part (input index)
  (p input index :frac-part
     (p-seq [(p-string <<".">>)
             (p-one-or-more digit/2)])))

(defn+ integer (input index)
  (p input index :integer
     int-part/2
     (fn (node idx)
         (let (result
               (erlang/list_to_integer
                (erlang/binary_to_list
                 (erlang/iolist_to_binary node))))
           {:integer result idx}))))

(defn+ e (input index)
  (p input index :e
     (p-seq [(p-charclass <<"[eE]">>)
             (p-optional (p-choose [(p-string <<"+">>)
                                    (p-string <<"-">>)]))])))

(defn+ exp-part (input index)
  (p input index :exp-part
     (p-seq [e/2
             (p-one-or-more digit/2)])))

(defn+ float (input index)
  (p input index :float
     (p-seq [int-part/2
             frac-part/2
             (p-optional exp-part/2)])
     (fn (node idx)
         (let (result (erlang/list_to_float
                       (erlang/binary_to_list
                        (erlang/iolist_to_binary node))))
           {:float result idx}))))

(defn+ char (input index)
  (p input index :char
     (p-seq [(p-string <<"\\">>)
             (p-choose [(p-string "\\\"")
                        (p-string "\\\\")
                        (p-string "\\b")
                        (p-string "\\f")
                        (p-string "\\n")
                        (p-string "\\r")
                        (p-string "\\t")
                        (p-anything)])])
     (fn (node idx)
         (case node
           ([_ <<"\\\"">>]
            {:char \" idx})
           ([_ <<"\\\\">>]
            {:char \\ idx})
           ([_ <<"\\b">>]
            {:char \\b idx})
           ([_ <<"\\f">>]
            {:char \\f idx})
           ([_ <<"\\n">>]
            {:char \\n idx})
           ([_ <<"\\r">>]
            {:char \\r idx})
           ([_ <<"\\t">>]
            {:char \\t idx})
           ([_ char]
            {:char char idx})))))

(defn+ ident (input index)
  (p input index :ident
     (p-one-or-more
      (p-and [(p-not
               (p-choose [(p-string <<"<<">>)
                          (p-string <<">>">>)
                          (p-string <<"~@">>)
                          (p-charclass <<"[,`~'\\\\{}/\t\n\s\r\\(\\)\\[\\]\"]">>)]))
              (p-anything)]))
     (fn (node idx)
         (let (result
               (erlang/list_to_atom
                (erlang/binary_to_list
                 (erlang/iolist_to_binary node))))
           {:ident result idx}))))

(defn+ symbol (input index)
  (p input index :symbol
     (p-seq [(p-string ":")
             ignorable/2
             (p-one-or-more
              (p-and [(p-not (p-charclass <<"[,\\\\{}\t\n\s\r\\(\\)\\[\\]\"]">>))
                      (p-anything)]))])
     (fn (node idx)
         (case node
           ([_ _ value]
            (let (result (erlang/list_to_atom
                          (erlang/binary_to_list
                           (erlang/iolist_to_binary value))))
              {:quote {:ident result idx} idx}))))))

(defn+ fun-reference (input index)
  (p input index :fun-reference
     (p-choose [(p-seq [ident/2
                        (p-string "/")
                        ident/2
                        (p-string "/")
                        integer/2])
                (p-seq [ident/2
                        (p-string "/")
                        integer/2])
                (p-seq [ident/2
                        (p-string "/")
                        ident/2])])
     (fn (node idx)
         (case node
           ([{:ident module _} _
             {:ident function _} _
             {:integer arity _}]
            {:call {:--fun module function arity} idx})
           ([{:ident function _} _
             {:integer arity _}]
            {:call {:--fun function arity} idx})
           ([{:ident module _} _
             {:ident function _}]
            {:call {:--fun module function} idx})))))

(defn+ string (input index)
  (p input index :string
     (p-seq [(p-string "\"")
             (p-zero-or-more (p-seq [(p-not (p-string "\""))
                                     (p-choose [(p-string "\\\"")
                                                (p-string "\\\\")
                                                (p-string "\\b")
                                                (p-string "\\f")
                                                (p-string "\\n")
                                                (p-string "\\r")
                                                (p-string "\\t")
                                                (p-anything)])]))
             (p-string "\"")])

     (fn (node idx)
         (case node
           ([_ string _]
            (let (convert (lists/map (fn (el)
                                         (case el
                                           ([_ <<"\\\"">>]
                                            <<"\"">>)
                                           ([_ <<"\\\\">>]
                                            <<"\\">>)
                                           ([_ <<"\\b">>]
                                            <<"\b">>)
                                           ([_ <<"\\f">>]
                                            <<"\f">>)
                                           ([_ <<"\\n">>]
                                            <<"\n">>)
                                           ([_ <<"\\r">>]
                                            <<"\r">>)
                                           ([_ <<"\\t">>]
                                            <<"\t">>)
                                           (_
                                            el)))
                                     string)
                          result (erlang/binary_to_list (erlang/iolist_to_binary convert)))
              {:string result idx}))))))


(defn+ quote (input index)
  (p input index :quote
     (p-seq [(p-string "'")
             value/2])
     (fn (node idx)
         (case node
           ([_ item]
            {:quote item idx})))))

(defn+ quasiquote (input index)
  (p input index :quasiquote
     (p-seq [(p-string "`")
             value/2])
     (fn (node idx)
         (case node
           ([_ item]
            {:quasiquote item idx})))))

(defn+ unquote (input index)
  (p input index :unquote
     (p-seq [(p-string "~")
             value/2])
     (fn (node idx)
         (case node
           ([_ item]
            {:unquote item idx})))))

(defn+ unquote-splicing (input index)
  (p input index :unquote-splicing
     (p-seq [(p-string "~@")
             value/2])
     (fn (node idx)
         (case node
           ([_ item]
            {:unquote-splicing item idx})))))

(defn+ list (input index)
  (p input index :list
     (p-choose [(p-seq [(p-string "(")
                        ignorable/2
                        value/2
                        (p-zero-or-more (p-seq [ignorable/2
                                                value/2]))
                        ignorable/2
                        (p-string ")")])
                (p-seq [(p-string "(")
                        ignorable/2
                        (p-string ")")])
                (p-seq [(p-string "[")
                        ignorable/2
                        value/2
                        (p-zero-or-more (p-seq [ignorable/2
                                                value/2]))
                        ignorable/2
                        (p-string "]")])
                (p-seq [(p-string "[")
                        ignorable/2
                        (p-string "]")])])
     (fn (node idx)
         (case node
           ([<<"(">> _ h t _ _]
            {:list (lists/flatten [h t]) idx})
           ([<<"[">> _ h t _ _]
            {:literal-list (lists/flatten [h t]) idx})
           ([<<"[">> _ _]
            {:literal-list [] idx})
           ([_ _ _]
            {:list [] idx})))))

(defn+ tuple (input index)
  (p input index :tuple
     (p-choose [(p-seq [(p-string "{")
                        ignorable/2
                        value/2
                        (p-zero-or-more (p-seq [ignorable/2
                                                value/2]))
                        ignorable/2
                        (p-string "}")])
                (p-seq [(p-string "{")
                        ignorable/2
                        (p-string "}")])])
     (fn (node idx)
         (case node
           ([_ _ h t _ _]
            {:tuple (lists/flatten [h t]) idx})
           ([_ _ _]
            {:tuple [] idx})))))

(defn+ binary (input index)
  (let (binary-contents (p-choose [integer/2
                                   char/2
                                   ident/2
                                   list/2]))
    (p input index :binary
       (p-choose [(p-seq [(p-string "<<")
                          ignorable/2
                          binary-contents
                          (p-zero-or-more (p-seq [ignorable/2
                                                  binary-contents]))
                          ignorable/2
                          (p-string ">>")])
                  (p-seq [(p-string "<<")
                          ignorable/2
                          string/2
                          ignorable/2
                          (p-string ">>")])
                  (p-seq [(p-string "<<")
                          ignorable/2
                          (p-string ">>")])])
       (fn (node idx)
           (case node
             ([_ _ h t _ _]
              {:binary (lists/flatten [h t]) idx})
             ([_ _ string _ _]
              {:binary string idx})
             ([_ _ _]
              {:binary [] idx}))))))

(defn+ value (input index)
  (p input index :value
     (p-seq [ignorable/2
             (p-choose [float/2
                        integer/2
                        binary/2
                        symbol/2
                        fun-reference/2
                        ident/2
                        list/2
                        tuple/2
                        string/2
                        quote/2
                        quasiquote/2
                        unquote-splicing/2
                        unquote/2
                        char/2])
             ignorable/2])
     (fn (node idx)
         (lists/nth 2 node))))

;; ### Path Hashing for Line and Type Information
;;
;; We have the problem that for macros and for ease of parsing we want
;; to keep the AST as clean as possible. That is, we want it to be as
;; close to a normal list as we can get away with. However, we want to
;; be able to hang information on the graph that the AST
;; represents. Things like line numbers, additional type information
;; etc. However, in erlang we cant do that without polluting the graph
;; itself and making it harder for user written macros to be
;; implemented. So we need some way to identify specific points in the
;; graph that is the AST that we can then use as a key on this
;; additional information that we would like to show.
;;
;; In an AST nodes are identified by their location in the graph. That
;; is, every node in the graph is identified by the path leading to
;; that node.  Lets look at an example.
;;
;;     (hello world (I rock))
;;
;; In this case the 'I' node could be identified by the path [hello,
;; world, <start of children>, I]. This should be a unique identifier
;; for any point in the graph assuming that there is a single root
;; term being parsed.
;;
;; If that is true we can replace the actual elements with their
;; positions in the list. So the example above would become. [1, 3,
;; 1]. Where the outer list is 1 (everything starts at one) the 3rd
;; position is the list and the first element in that third
;; position. Lets look at something a bit more something more realistic.
;;
;;     (defn+ hello-world [foo bar] (baz bang bong))
;;
;; In this example the bang node could be identified by everything
;; leading up to it. So the path would be [defn+, hello-world,
;; <children>, <start-of_children>, bang]. Lets translate this to our
;; simple numerical paths. [1, 4, 2]. This should work to any level in
;; the graph.
;;
;; We can make it even easier to manipulate buy having the firstest
;; point in the graph be the closest point in the list so that we can
;; push onto the list as we go forward. The actual path in the example
;; above would be [2, 4, 1] and built up each time we see a list.

(defn+ new-path ()
  {1, []})

(defn+ incr-path (pos path)
  (case path
    ({oldpos oldpath}
     {(+ pos oldpos) oldpath})))

(defn+ incr-path (path)
  (incr-path 1 path))

(defn+ traverse-path (path)
  (case path
    ({old-position old-path}
     {1, (old-position . old-path)})))

(defn+ path? (path)
  (case path
    ({_ old-path}
     old-path)))

(defn+ traverse-and-get-path (path)
  (path? (traverse-path path)))

(defn+ traverse-incr-path (path)
  (traverse-path (incr-path path)))

(defn+ traverse-incr-path (amount path)
  (traverse-path (incr-path amount path)))


;; ### Annotation storage and retrieval
;;
;; With path support in place its time take care of the annotations
;; themselves. We want the api to handle formating and internal
;; storage forms. As long as we give it a good path we want to get
;; back what we ask for.
(defn+ new-annots (file-name)
  (ec_dictionary/add :__filename__ file-name (ec_dictionary/new :ec_dict)))

(defn+ add-annots (path type idx annotations)
  (let (file-name (ec_dictionary/get :__filename__ annotations))
    (case idx
      ({line _}
       (ec_dictionary/add path {type idx [line, {:file file-name}]}
                          annotations)))))

;; sometimes an invalid path is passed in. This is unfortunate but
;; things like macros mangle the path in currently unforseable
;; ways. With this in mind we keep backing up the path until such time
;; that we get a valid annotation. This lets us give at least the line
;; number and annotations of the top most related form.
(defn get-valid-annots (path annotations)
  (case path
    ([]
     :not-found)
    ((_ . rest)
     (__try
      (ec_dictionary/get path annotations)
      (catch (type body)
        (case {type body}
          ({:throw :not_found}
           (get-valid-annots rest annotations))))))))

(defn+ get-type-annots (path annotations)
  (case (get-valid-annots path annotations)
    (:not-found
     :unknown)
    ({type _ _}
     type)))

(defn+ get-idx-annots (path annotations)
  (case (get-valid-annots path annotations)
    (:not-found
     {0 0})
    ({_ idx _}
     idx)))

(defn+ get-line-annots (path annotations)
  (case (get-valid-annots path annotations)
    (:not-found
     {"" {0 0}})
    ({_ _ line}
     line)))

(defn+ get-line-annots (path extra annotations)
  (let (annots (get-line-annots path annotations))
    (extra . annots)))

;; ### The First Ast Transformation
;;
;; Most of the AST transformations in Joxa happen via macros. however,
;; this very first initial transformation happens here. Turning the
;; marked up AST into an annotated lisp AST where the annotations are
;; hidden unless requested.

(definline convert-list-ast (path0 annotations0 elements idx)
  (let (transformed
        (lists/foldl
         (fn (el, acc)
             (case acc
               ({path1 annotations1 elements-acc}
                (let (result (transform-ast
                              (traverse-path path1)
                              annotations1 el))
                  (case result
                    ({annotations2 transformed}
                     {(incr-path path1) annotations2
                      (transformed . elements-acc)}))))))
         {path0 annotations0 []}
         elements))
    transformed))

(definline convert-list-call-ast (path0 annotations0 elements idx type)
  (let (transformed
        (convert-list-ast (incr-path path0)
                          annotations0 elements idx))
    (case transformed
      ({_ annotations3 transform-list}
       (let (annotations4 (add-annots (traverse-and-get-path path0)
                                      :ident
                                      idx annotations3))
         {(add-annots (path? path0)
                      type idx
                      annotations4)
          (type . (lists/reverse transform-list))})))))

(definline convert-binary-string (path0 annotations0 elements idx)
  (let (transformed
        (lists/foldl
         (fn (el, acc)
             (case acc
               ({path1 annotations1 elements-acc}
                {(incr-path path1)
                 (add-annots (traverse-and-get-path path1)
                             :integer
                             idx
                             annotations1)
                 (el . elements-acc)})))
         {path0 annotations0 []}
         elements))
    (case transformed
      ({_ annotations3 transform-list}
       (let (annotations4 (add-annots
                           (traverse-and-get-path path0)
                           :ident
                           idx annotations3))
         {(add-annots (path? path0)
                      :binary idx
                      annotations4)
          (:binary . (lists/reverse transform-list))})))))

(defn+ transform-ast (path0 annotations node)
  (case node
    (:fail
     (erlang/throw :fail))
    ({:call mfa idx}
     {(add-annots (path? path0)
                  :call idx annotations) mfa})
    ({:literal-list list idx}
     (convert-list-call-ast path0 annotations list idx :list))
    ({:binary {:string string _} idx}
     (convert-binary-string path0 annotations string idx))
    ({:binary list idx}
     (convert-list-call-ast path0 annotations list idx :binary))
    ({:tuple list idx}
     (let (transformed (convert-list-ast path0 annotations list idx))
       (case transformed
         ({_ annotations1 transform-list}
          {(add-annots (path? path0)
                       :tuple idx
                       annotations1)
           (erlang/list_to_tuple (lists/reverse transform-list))}))))
    ({:list list idx}
     (let (transformed (convert-list-ast path0 annotations list idx))
       (case transformed
         ({_ annotations1 transform-list}
          {(add-annots (path? path0)
                       :list idx
                       annotations1)
           (lists/reverse transform-list)}))))
    ({:string result idx}
     {(add-annots (path? path0) :string idx
                  (add-annots (traverse-and-get-path path0)
                              :ident idx
                              annotations))
      [:string, result]})
    ({type (= val {_ _ _}) idx}
     (let (result (transform-ast (traverse-incr-path path0)
                                 annotations val))
       (case result
         ({annotations1 p-val}

          {(add-annots (path? path0) type idx
                       (add-annots (traverse-and-get-path path0)
                                   :ident idx
                                   annotations1))
           [type, p-val]}))))
    ({type val idx}
     {(add-annots (path? path0) type idx annotations) val})))

;; These are mostly exponsed for testing purposes
(defn+ intermediate-parse (input index)
  (setup-memo)
  (let (result (value input index))
    (release-memo)
    result))

(defn+ intermediate-parse (input)
  (intermediate-parse input {1,1}))

(defn+ new-index ()
  {1,1})

(defn+ has-more-data-to-parse (input)
  (case input
    (<<>>
     :false)
    ({:parse-output <<>> _ _ _}
     :false)
    (_
     :true)))

(defn do-parse (path annots input idx0)
  (case input
    (<<>>
     {<<>> path annots idx0})
    (_
     (case (intermediate-parse input idx0)
       ({:fail {:expected expected idx1}}
        (erlang/throw {:invalid-form expected idx0}))
       ({intermediate-ast rest idx2}
        (case (transform-ast (traverse-path path) annots
                             intermediate-ast)
          ({annots1 final-ast}
           {annots1 final-ast {:parse-output rest path annots1 idx2}})))))))

(defn+ parse (file-name input)
  (case input
    (input (when (erlang/is_binary input))
           (do-parse (new-path)
                     (new-annots file-name)
                     input
                     (new-index)))
    ({:parse-output new-input path annots index}
     (do-parse (incr-path path) annots new-input index))))

(defn+ parse-file (filename)
  (case (file/read_file filename)
    ({:ok bin}
     (parse filename bin))))

;; Module Compilation
;; ------------------
;;
;; The form of the module is defined as follows.
;;
;;     (module <module_name>
;;        <require>
;;        <use>
;;        <attributes>)
;;
;; The module clause is a special form and its contents are not evaluated.
;;
;; comp compiles the provided AST into a Joxa context. Later that context
;; must be compiled to core erlang.
(defn get-exports (module idx)
  (let (mod-info (erlang/make_fun module :module_info 1)
        exports (mod-info :exports))
    (lists/map (fn (el)
                   (case el
                     ({fun arity}
                      {{fun arity} fun})))
               exports)))

(defn gather-fun-arity-pairs (idx fun-arity-list acc)
  (case fun-arity-list
    (({:--fun fun arity} . rest)
     (gather-fun-arity-pairs idx rest ({fun arity} . acc)))
    ([] acc)
    (_
     (erlang/throw {:invalid-use :invalid-fun-spec idx}))))

(defn gather-fun-alias-pairs (idx fun-alias-pairs acc)
  (case fun-alias-pairs
    (([{:--fun fun arity} alias] . rest)
     (when (erlang/is_atom alias))
     (gather-fun-alias-pairs idx rest ({{fun arity} alias} . acc)))
    ([]
     acc)
    (_
     (erlang/throw {:invalid_use :invalid_fun_spec idx}))))

(defn populate-use-into-context (ctx module-name imports)
  (case imports
    ([]
     :ok)
    (_
     (lists/foreach (fn (el)
                        (case el
                          ({{fun-name arity} alias-name}
                           (add-use-ctx ctx alias-name arity fun-name module-name))))
                    imports))))

;; Joxa Module Definitions
;; -----------------------
;;
;; Module declarations in Joxa are more complex then module definitions in
;; Erlang. They follow the Clojure model much more closely then the Erlang
;; module. That is that all modules used in the system must be required. You
;; may provide an alias for a dependent module name in both the require
;; clause and the use clauses. You may also import functions from modules in
;; the use clause.
;;
;; ### Module Form
;; The form of the module is defined as follows.
;;
;;     (module <module_name>
;;        <require>
;;        <use>
;;        <attributes>)
;;
;; The module clause is a special form and its contents are not evaluated.
;;
;; comp compiles the provided AST into a Joxa context. Later that context
;; must be compiled to core erlang.
(defn filter-imports-to-onlys (idx target-funs imports0)
  (let (fun-arity-pairs (gather-fun-arity-pairs idx target-funs '()))
    (lists/foldl (fn (el acc)
                     (case el
                       ({fun arity}
                        (let (new-el {{fun arity} fun})
                          (case (lists/member new-el imports0)
                            (:true
                             (new-el . acc))
                            (:false
                             (erlang/throw {:invalid-use :non-existant-fun-name {fun arity} idx})))))))
                 [] fun-arity-pairs)))

(defn exclude-specific-funs (idx excluded-funs imports0)
  (let (fun-arity-pairs (gather-fun-arity-pairs idx excluded-funs []))
    (lists/foldl (fn (el acc)
                     (case el
                       ({{fun arity} _}
                        (let (new-el {{fun arity} fun})
                          (case (lists/member {fun arity} fun-arity-pairs)
                            (:true
                             acc)
                            (:false
                             (new-el . acc)))))))
                 [] imports0)))

(defn rename-funs (idx renames imports0)
  (let (fun-alias-pairs (gather-fun-alias-pairs idx renames []))
    (lists/foldl (fn (el exports1)
                     (case el
                       ({{fun arity} alias}
                        (lists/keyreplace {fun arity} 1 exports1
                                          {{fun arity} alias}))))
                 imports0 fun-alias-pairs)))

(defn handle-use-clauses (idx ctx forms module-name imports0)
  (case forms
    ([]
     (populate-use-into-context ctx module-name imports0))
    (('(quote as) . (alias-name . rest))
     (add-alias-ctx ctx alias-name module-name)
     (handle-use-clauses idx ctx rest module-name imports0))
    (('(quote only) . (target-funs . rest))
     (when (and (erlang/is_atom module-name)
                (erlang/is_list target-funs)))
     (let (imports1 (filter-imports-to-onlys idx target-funs imports0))
       (handle-use-clauses idx ctx rest module-name imports1)))
    (('(quote exclude) . (target-funs . rest))
     (when (and (erlang/is_atom module-name)
                (erlang/is_list target-funs)))
     (let (imports1 (exclude-specific-funs idx target-funs imports0))
       (handle-use-clauses idx ctx rest module-name imports1)))
    (('(quote rename) . (target-funs . rest))
     (when (and (erlang/is_atom module-name)
                (erlang/is_list target-funs)))
     (let (imports1 (rename-funs idx target-funs imports0))
       (handle-use-clauses idx ctx rest module-name imports1)))
    (probably-more-uses
     (comp-use idx ctx probably-more-uses module-name imports0))))

(defn module-exists? (mod-name)
  (case (code/ensure_loaded mod-name)
    ({:module _}
     :true)
    ({:error :embedded}
     :true)
    ({:error :native_code}
     :true)
    (_
     :false)))

;; Use Clauses
;; -----------
;;
;; At last we get to the use clauses. Use clauses are, by far, the most
;; complex of the header clauses as the both manipulate and subset the
;; functions buing used while at the same time aliasing the function if
;; required.
;;
;;     (use string)
;;     (use [string :only [tokens/2]])
;;     (use [string :exclude [substr/3 join/2 join/3]])
;;     (use [string :rename ([substr/3 str-substring] [join/2 str-join])])
;;     (use [string :as str :only [join/2 substr/3]])
;;     (use [string :as str :only [tokens/2]])
;;     (use [string :as str :exclude [substr/3 join/2 join/3]])
;;     (use [string :as str :rename ([substr/3 str-substring] [join/2 str-join])])
;;
;; As you can see each clause may consist of a module name, or a vector/list
;; that contains a few some clauses.  The subcluase is always headed by a
;; module name, followed by an action, followed by the subject of that
;; action. The subclause action/subject may ocurre in any order. Even though
;; some do not make sense when used together. So, for example you could have
;; the following
;;
;;     (use [string :rename ([substr/3 str-substring] [join/2 str-join]
;;                  :exclude [substr/4 join/2]
;;                  :as str)])
;;
;; This would be perfectly valid and could use occur in any order at all.

(defn+ comp-use (idx ctx form module-name imports)
  (case form
    ([]
     (populate-use-into-context ctx module-name imports))
    (((use-module-name . clause-body) . rest)
     (when (erlang/is_atom use-module-name))
     (case (module-exists? use-module-name)
       (:true
        (let (imports (get-exports use-module-name idx))
          (add-require-ctx ctx use-module-name)
          (handle-use-clauses idx ctx
                              clause-body use-module-name imports)
          (comp-use idx ctx rest :undefined '())))
       (:false
        (erlang/throw {:invalid-use-clause {:bad-module use-module-name} idx}))))
    ((use-module-name . rest)
     (when (erlang/is_atom use-module-name))
     (let (imports (get-exports use-module-name idx))
       (populate-use-into-context ctx use-module-name imports)
       (comp-use idx ctx rest :undefined '())))))

;; Attribute Clauses
;; -----------------
;;
;; Attribute clauses are the simplest of the three clauses There are simply
;; a three element list where the first element is the ident 'attr', the
;; second element is a Joxa term that provides the key value and the third
;; is a Joxa term that provides the value.
;;
;; Attributes follow the form:
;;
;;     (attr <key> <value>)
;;
(defn+ comp-attr (path0 ctx form)
  (case form
    ([key value]
     (add-attr-ctx ctx
      (make-literal (traverse-path path0) ctx key)
      (make-literal (traverse-incr-path path0) ctx value)))
    (_
     (let (idx (idx-from-context :traverse path0 ctx))
       (erlang/throw {:invalid-attr-clause idx})))))

;; ### Require Clause
;;
;; The require clause is a list that starts with the ident 'require' and
;; then contains a require body. Examples of the require and require bodies
;; appear below.
;;
;;     (require (erlang string test))
;;     (require string [test :as test])
;;     (require [string :as str])
;;     (require [string :as str1])
;;     (require string test)
;;
;; The body of the require contains a list of require clauses, in the form
;;
;;    (erlang string test)
;;    (string [test :as test])
;;
;;  or a simple group of require clauses in the form:
;;
;;    string test
;;    [string :as str] compiler
;;
;; Each clause is a module name or a module alias form in the form:
;;
;;    [string :as str]
;;
(defn+ comp-require (path0 ctx form)
  (case form
    ([]
     ctx)
    ((module-name . rest)
     (when (erlang/is_atom module-name))
     (case (module-exists? module-name)
       (:true
        (add-require-ctx ctx module-name)
        (comp-require (incr-path path0) ctx rest))
       (:false
        (let (idx (idx-from-context [] path0 ctx))
          (erlang/throw {:invalid-require-clause {:bad-module module-name} idx})))))
    (([module-name [quote as] module-alias]  . rest)
     (when (and (erlang/is_atom module-name)
                (erlang/is_atom module-alias)))
     (case (module-exists? module-name)
       (:true
        (add-require-ctx ctx module-name)
        (add-alias-ctx ctx module-alias module-name)
        (comp-require (incr-path path0) ctx rest))
       (:false
        (let (idx (idx-from-context [] path0 ctx))
          (erlang/throw {:invalid-require-clause {:bad-module module-name} idx})))))
    (clause
     (let (idx (idx-from-context :traverse path0 ctx))
       (erlang/throw {:invalid-require-clause clause idx})))))


;; ### Module Body
;;
;;  The module body may consist of any number of require, use are attribute
;;  clauses in any order. Each clause starts with a (require ...)
;;  (use ....) or (attr ...)
;;b
(defn+ comp-module-body (path0 ctx form)
  (case form
    ([]
     ctx)
    ((:require . body)
     (comp-require (incr-path path0) ctx body))
    ((:attr . body)
     (comp-attr (incr-path path0) ctx body))
    ((:use . body)
     (let (idx (idx-from-context [] path0 ctx))
       (comp-use idx ctx body :undefined [])))
    (_
     (let (idx (idx-from-context [] path0 ctx))
       (erlang/throw {:invalid-form idx})))))

(defn+ comp-module (path0 ctx forms)
  (let (path1 (traverse-path path0))
    (case forms
      ((:module . (module-name . rest))
       (module-name-ctx ctx module-name)
       (let (annots (annots-from-context [] path0 ctx))
         (lists/foldl
          (fn (form path2)
              (comp-module-body (traverse-path path2) ctx form)
              (incr-path path2))
          (incr-path 2 path0) rest)
         (line-ctx ctx annots)
         :ok))
      (_
       (let (idx (idx-from-context [] path1 ctx))
         (erlang/throw {:invalid-module-declaration idx}))))))

(defn make-tuple-expr (path0 ctx values)
  (case (lists/foldl (fn (val acc0)
                         (case acc0
                           ({path1 acc1}
                            (let (element (comp-expr (traverse-path path1) ctx val))
                              {(incr-path path1) (element . acc1)}))))
                     {path0 []} values)
    ({_ body}
      (cerl/ann_c_tuple (annots-from-context [] path0 ctx)
                        (lists/reverse body)))))
(defn make-seq (path0 ctx form)
  (let (annots (annots-from-context :traverse path0 ctx))
    (case form
      ([arg1 arg2]
       (let (cerl-arg1 (comp-expr (traverse-path path0) ctx arg1)
             cerl-arg2 (comp-expr (traverse-incr-path path0) ctx arg2))
         (cerl/ann_c_seq annots cerl-arg1 cerl-arg2)))
      ([arg1]
       (comp-expr (traverse-path path0) ctx arg1))
      ((arg1 . rest)
       (let (cerl-arg1 (comp-expr (traverse-path path0) ctx arg1)
              cerl-arg2 (make-seq (incr-path path0) ctx rest))
         (cerl/ann_c_seq annots cerl-arg1 cerl-arg2)))
      ([]
       (erlang/throw {:invalid-sequence (idx-from-context [] path0 ctx)})))))

(defn make-cons (annots arg1-path arg2-path ctx arg1 arg2)
  (let (cerl-arg1 (comp-expr arg1-path ctx arg1)
        cerl-arg2 (comp-expr arg2-path ctx arg2))
    (cerl/ann_c_cons annots cerl-arg1 cerl-arg2)))

(defn args-to-list (args)
  (case args
    ([]
     (cerl/ann_c_nil [:compiler_generated]))
    ((arg . rest)
     (cerl/ann_c_cons [:compiler_generated]
                      arg
                      (args-to-list rest)))))

(defn args-to-arity (args0 count arity acc)
  (case args0
    ([]
     (lists/reverse acc))
    ((arg . rest)
     (case (erlang/< count arity)
       (:true
         (args-to-arity rest (erlang/+ count 1) arity (arg . acc)))
        (:false
         (args-to-arity [] 0 arity ((args-to-list args0) . acc)))))))

(defn runtime-args-to-arity (args0 count arity acc)
  (case args0
    ([]
     (lists/reverse acc))
    ((arg . rest)
     (case (erlang/< count arity)
       (:true
         (runtime-args-to-arity rest (erlang/+ count 1) arity (arg . acc)))
        (:false
        (lists/reverse (args0 . acc)))))))

(defn eval-args (path0 ctx args0)
  (case (lists/foldl (fn (arg acc0)
                         (case acc0
                           ({path1 acc1}
                            (let (cerl (comp-expr (traverse-path path1) ctx arg))
                              {(incr-path path1) (cerl . acc1)}))))
                     {path0 []} args0)
    ({_ args1}
     (lists/reverse args1))))

(defn add-to-annots (cerl-thing annots)
  (let (old-annots (lists/filter (fn (el)
                                     (case el
                                       ({:rest _}
                                        :true)
                                       ({:not-rest _}
                                        :true)
                                       (_
                                        :false)))
                                 (cerl/get_ann cerl-thing)))
    (cerl/set_ann cerl-thing (lists/append old-annots annots))))

(defn+ gensym ()
  (let (x (erlang/phash2 {(erlang/node) (erlang/now ) (crypto/rand_bytes 16)})
        bit-rep (lists/map (fn (el)
                               (io_lib/format "~.16B" [el]))
                           (erlang/binary_to_list
                            (binary/encode_unsigned x))))
    (erlang/list_to_atom
     (lists/flatten
      (io_lib/format "GENSYM_~s" [bit-rep])))))

(defn is-rest-var? (var)
  (let (annots (cerl/get_ann var))
    (case (lists/keysearch :rest 1 annots)
      ({value val}
       val)
      (_
       (case (lists/keysearch :not-rest 1 annots)
         ({value val}
          val)
         (_
          :unknown))))))

(defn make-rest-apply-var (ctx annots cerl-var arg-list)
  (case (is-rest-var? cerl-var)
    ({:rest arity}
     (cerl/ann_c_apply annots
                       cerl-var
                       (args-to-arity arg-list 1 arity [])))
    (_
     (cerl/ann_c_apply annots
                             cerl-var
                             arg-list))))

(defn make-apply (path0 ctx form)
  (let (annots (annots-from-context [] path0 ctx))
    (case form
      ((:apply . (target . args))
       (let (arg-list (eval-args (incr-path 2 path0) ctx args))
         (case (resolve-reference-ctx path0 ctx target (erlang/length args))
           ({:remote :not-rest _ {module function arity}}
            (cerl/ann_c_call annots
                             (cerl/ann_c_atom annots module)
                             (cerl/ann_c_atom annots function)
                             (eval-args (incr-path 2 path0) ctx args)))
           ({:remote :rest _ {module function arity}}
            (cerl/ann_c_call annots
                             (cerl/ann_c_atom annots module)
                             (cerl/ann_c_atom annots function)
                             (args-to-arity arg-list 1 arity [])))
           ({:apply :not-rest _ {function arity}}
            (add-fun-dep-ctx ctx function arity)
            (cerl/ann_c_apply annots
                              (cerl/ann_c_fname annots function arity)
                              arg-list))
           ({:apply :rest _ {function arity}}
            (add-fun-dep-ctx ctx function arity)
            (cerl/ann_c_apply annots
                              (cerl/ann_c_fname annots function arity)
                              (args-to-arity arg-list 1 arity [])))
           ({:reference {val _}}
            (make-rest-apply-var ctx annots val arg-list))
           (:not-a-reference
            (cerl/ann_c_apply annots
                              (comp-expr (traverse-path path0) ctx target)
                              arg-list)))))
      (_
       (erlang/throw {:invalid-reference form
                                         (idx-from-context [] path0 ctx)})))))

(defn make-apply-rest-fun (ctx f-var arity rest-arity)
  (let (arg-list (lists/map (fn (_)
                                (cerl/ann_c_var [:compiler_generated]
                                                (gensym)))
                            (lists/seq 1 arity))
        annots [:compiler_generated])
    (incr-fun-index-ctx ctx)
    (cerl/ann_c_fun annots arg-list
                     (cerl/ann_c_apply annots
                                     f-var
                                     (args-to-arity arg-list 1 rest-arity [])))))

(defn make-remote-rest-fun (ctx module function arity rest-arity)
  (let (arg-list (lists/map (fn (_)
                                (cerl/ann_c_var [:compiler_generated]
                                                (gensym)))
                            (lists/seq 1 arity))
                 annots [:compiler_generated])
    (incr-fun-index-ctx ctx)
    (cerl/ann_c_fun annots arg-list
                    (cerl/ann_c_call annots
                                     (cerl/ann_c_atom annots module)
                                     (cerl/ann_c_atom annots function)
                                     (args-to-arity arg-list 1 rest-arity [])))))


(defn make-fun (path0 ctx form)
  (let (annots (annots-from-context [] path0 ctx))
    (case form
      ({:--fun f a} (when (erlang/is_integer a))
       (case (resolve-reference-ctx path0 ctx f a)
         ({:reference {var _}}
          (case (erlang/and (cerl/is_c_fname var)
                            (== (cerl/fname_arity var) a))
            (:true
             (add-to-annots var annots))
            (:false
             (let (idx (idx-from-context [] path0 ctx))
               (erlang/throw {:invalid-reference {f a} idx})))))
         ({:apply :not-rest _ {name a}}
          (add-fun-dep-ctx ctx name a)
          (cerl/ann_c_fname annots name a))
         ({:apply :rest _ {name rest-arity}}
          (add-fun-dep-ctx ctx name rest-arity )
          (make-apply-rest-fun ctx
                               (cerl/ann_c_fname annots name a)
                               a rest-arity))
         (_
          (let (idx (idx-from-context [] path0 ctx))
            (erlang/throw {:invalid-reference {f a} idx})))))
      ((= ref {:--fun _ _ a})
       (when (erlang/is_integer a))
       (case (resolve-reference-ctx path0 ctx ref a)
         ({:reference {_ _}}
          (erlang/throw {:invalid-reference (idx-from-context [] path0 ctx)}))
         ({:remote :not-rest _ {module function arity}}
          (when (erlang/and (erlang/is_atom module)
                            (erlang/is_atom function)))
          (cerl/ann_c_call annots
                           (cerl/ann_c_atom annots
                                            :erlang)
                           (cerl/ann_c_atom annots
                                            :make_fun)
                           [(cerl/ann_c_atom annots module)
                            (cerl/ann_c_atom annots function)
                            (cerl/ann_c_int annots arity)]))
         ({:remote :rest _ {module function rest-arity}}
          (when (erlang/and (erlang/is_atom module)
                            (erlang/is_atom function)))
          (make-remote-rest-fun ctx module function a rest-arity))
         (_
          (erlang/throw {:undefined-reference ref (idx-from-context [] path0 ctx)}))))
      (_
       (erlang/throw {:undefined-reference form (idx-from-context [] path0 ctx)})))))

(defn make-list (path0 ctx form)
  (let (annots (annots-from-context :traverse path0 ctx))
    (case form
      ([]
       (cerl/c_nil))
      ((h . t)
       (let (cerl-h (comp-expr (traverse-path path0) ctx h)
             cerl-t (make-list (incr-path path0)  ctx t))
         (cerl/ann_c_cons annots cerl-h cerl-t))))))

(defn call-macro (module function args)
  (erlang/apply module function args))

(defn make-call (path0 ctx val args macro-only?)
  (let (annots (annots-from-context [] path0 ctx))
    (let (possible-arity (erlang/length args)
          path1 (traverse-path path0)
          call-annots (annots-from-context [] path1 ctx))
      (case (resolve-reference-ctx path0 ctx val possible-arity)
        ({:apply :not-rest :macro {function arity}}
            (comp-expr path0 ctx
                       (call-macro (module-name-ctx ctx) function args)))
           ({:apply :rest :macro {function arity}}
            (comp-expr path0 ctx
                       (call-macro (module-name-ctx ctx) function
                                              (runtime-args-to-arity args 1 arity []))))
           ({:remote :not-rest :macro {module function arity}}
            (comp-expr path0 ctx
                       (call-macro  module function
                                              args)))
           ({:remote :rest :macro {module function arity}}
            (comp-expr path0 ctx
                       (call-macro module function
                                   (runtime-args-to-arity args 1 arity []))))
           (ref
            (let (arg-list (eval-args (incr-path path0) ctx args))
              (case ref
                ({:reference {var _}}
                 (when (erlang/== :false macro-only?))
                 (make-rest-apply-var ctx annots (add-to-annots var annots) arg-list))
                ({:apply :not-rest _ {name arity}}
                 (when (erlang/== :false macro-only?))
                 (add-fun-dep-ctx ctx name arity)
                 (cerl/ann_c_apply annots
                                   (cerl/ann_c_fname call-annots
                                                     name
                                                     arity)
                                   arg-list))
                ({:apply :rest _ {name arity}}
                 (when (erlang/== :false macro-only?))
                 (add-fun-dep-ctx ctx name arity)
                 (cerl/ann_c_apply annots
                                   (cerl/ann_c_fname call-annots
                                                     name
                                                     arity)
                                   (args-to-arity arg-list 1 arity [])))
                ({:remote :not-rest _ {module function possible-arity}}
                 (when (erlang/== :false macro-only?))
                 (cerl/ann_c_call annots
                                   (cerl/ann_c_atom call-annots
                                                    module)
                                   (cerl/ann_c_atom call-annots
                                                    function)
                                   arg-list))
                ({:remote :rest _ {module function arity}}
                 (when (erlang/== :false macro-only?))
                 (cerl/ann_c_call annots
                                  (cerl/ann_c_atom call-annots
                                                   module)
                                  (cerl/ann_c_atom call-annots
                                                   function)
                                  (args-to-arity arg-list 1 arity [])))
                ({:error error}
                 (erlang/throw {error (idx-from-context [] path0 ctx)}))
                (:not-a-reference
                 (when (erlang/and (erlang/== :false macro-only?)
                                   (erlang/is_list val)))
                 (let (cerl-val (comp-expr (traverse-path path0) ctx val))
                   (make-rest-apply-var ctx annots (add-to-annots cerl-val annots) arg-list)))
                (:not-a-reference
                 (when (erlang/== :false macro-only?))
                 (case (resolve-reference-ctx path0 ctx val -1)
                   ({:reference {var _}}
                    (make-rest-apply-var ctx annots (add-to-annots var annots) arg-list))
                    (_
                     (erlang/throw {:invalid-reference val possible-arity
                                                       (idx-from-context [] path0 ctx)})))))))))))

(defn make-try (path0 ctx form)
  (let (annots (annots-from-context [] path0 ctx))
    (case form
      ([:__try expr [:catch [type value] catch-expr]]
       (when (erlang/and (erlang/is_atom type)
                         (erlang/is_atom value)))
       (let (cerl-expr (comp-expr (traverse-incr-path path0) ctx expr)
             try-var (cerl/ann_c_var (:compiler_generated . annots) (gensym))
             type-var (cerl/ann_c_var annots type)
             value-var (cerl/ann_c_var annots value)
             ignore-var (cerl/ann_c_var (:compiler_generated . annots) (gensym)))
         (push-scope-ctx ctx)
         (add-reference-to-scope-ctx path0 ctx value -1 value-var)
         (add-reference-to-scope-ctx path0 ctx type -1 type-var)
         (let (cerl-catch (comp-expr (incr-path (traverse-incr-path 2 path0)) ctx catch-expr))
           (pop-scope-ctx ctx)
           (cerl/ann_c_try annots cerl-expr [try-var] try-var
                           [type-var value-var ignore-var]
                           cerl-catch))))
      (_
       (erlang/throw {:invalid-try-expression (idx-from-context [] path0 ctx)})))))

(defn get-bitstring (field bit)
  (case field
    (:var (erlang/element 2 bit))
    (:size (erlang/element 3 bit))
    (:unit (erlang/element 4 bit))
    (:type (erlang/element 5 bit))
    (:signedness (erlang/element 6 bit))
    (:endianness (erlang/element 7 bit))
    (_ (erlang/throw {:invalid-field :bitstring field}))))

(defn set-bitstring (field value bit)
  (case field
    (:var (erlang/setelement 2 bit value))
    (:size (erlang/setelement 3 bit value))
    (:unit (erlang/setelement 4 bit value))
    (:type (erlang/setelement 5 bit value))
    (:signedness (erlang/setelement 6 bit value))
    (:endianness (erlang/setelement 7 bit value))
    (_ (erlang/throw {:invalid-field :bitstring field}))))

(defn new-bitstring ()
  {:bitstring
   :undefined
   :undefined
   :undefined
   :integer
   :unsigned
   :big})

(defn resolve-bitstring-defaults (idx value)
  (case value
    (:invalid
     (erlang/throw {:invalid-bitstring-spec idx}))
    (_
     (let (annots '(compiler_generated)
                  size0 (get-bitstring :size value)
                  unit0 (get-bitstring :unit value)
                  type0 (get-bitstring :type value)
                  size1 (case size0
                          (:undefined
                           (case type0
                             (:integer 8)
                             (:float 64)
                             (:binary [:quote :all])
                             (:bitstring 1)
                             (:bits 1)
                             (:utf8 [:quote :undefined])
                             (:utf16 [:quote :undefined])
                             (:utf32 [:quote :undefined])))
                          (val
                           val))
                  unit1 (case unit0
                          (:undefined
                           (case type0
                             (:float (cerl/ann_c_int annots 1))
                             (:integer (cerl/ann_c_int annots 1))
                             (:bitstring (cerl/ann_c_int annots 1))
                             (:bits (cerl/ann_c_int annots 1))
                             (:binary (cerl/ann_c_int annots 8))
                             (:utf8 (cerl/ann_c_int annots :undefined))
                             (:utf16 (cerl/ann_c_int annots :undefined))
                             (:utf32 (cerl/ann_c_int annots :undefined))))
                          (val
                           (when (erlang/is_integer val))
                           (cerl/ann_c_int annots val))))
       (set-bitstring :size size1
                      (set-bitstring :unit unit1 value))))))

(defn convert-bitstring (pairs bitstring)
  (case pairs
    (([:quote :size] . (value . rest))
     (convert-bitstring rest (set-bitstring :size value bitstring)))
    (([:quote :unit] . (value . rest))
     (convert-bitstring rest (set-bitstring :unit value bitstring)))
    (([:qute :little] . rest)
     (convert-bitstring rest (set-bitstring :endianness :little bitstring)))
    (([:quote :big] . rest)
     (convert-bitstring rest (set-bitstring :endianness :big bitstring)))
    (([:quote :native] . rest)
     (convert-bitstring rest (set-bitstring :endianness :native bitstring)))
    (([:quote :signed] . rest)
     (convert-bitstring rest (set-bitstring :signedness :signed bitstring)))
    (([:quote :unsigned] . rest)
     (convert-bitstring rest (set-bitstring :signedness :unsigned bitstring)))
    (([:quote :integer] . rest)
     (convert-bitstring rest (set-bitstring :type :integer bitstring)))
    (([:quote :binary] . rest)
     (convert-bitstring rest (set-bitstring :type :binary bitstring)))
    (([:quote :utf8] . rest)
     (convert-bitstring rest (set-bitstring :type :utf8 bitstring)))
    (([:quote :utf16] . rest)
     (convert-bitstring rest (set-bitstring :type :utf16 bitstring)))
    (([:quote :utf32] . rest)
     (convert-bitstring rest (set-bitstring :type :utf32 bitstring)))
    (([:quote :float] . rest)
     (convert-bitstring rest (set-bitstring :type :float bitstring)))
    ([]
     bitstring)
    (_
     :invalid)))

(defn make-binary-element (element acc0)
  (case acc0
    ({path0 ctx acc1}
     (let (idx (idx-from-context [] path0 ctx))
       (case element
         ((var . pairs0)
          (let (path1 (traverse-path path0)
                bitstring
                (resolve-bitstring-defaults idx
                                            (convert-bitstring pairs0
                                                               (new-bitstring)))
                annots (annots-from-context :traverse path1 ctx)
                cerl-var (comp-expr path1 ctx var)
                size (comp-expr path1 ctx (get-bitstring :size bitstring)))
            {(incr-path path1) ctx
             ((cerl/ann_c_bitstr annots
                                 cerl-var
                                 size
                                 (get-bitstring :unit bitstring)
                                 (cerl/ann_c_atom annots
                                                  (get-bitstring :type bitstring))
                                 (cerl/ann_make_list annots
                                                     [(cerl/ann_c_atom annots
                                                                       (get-bitstring :signedness bitstring))
                                                      (cerl/ann_c_atom annots
                                                                       (get-bitstring :endianness bitstring))]))
              . acc1)}))
         (var (when (erlang/or (erlang/is_atom  var)
                               (erlang/is_integer var)))
              (let (annots (annots-from-context :traverse path0 ctx)
                    bitstring (resolve-bitstring-defaults idx (new-bitstring))
                    cerl-var (comp-expr path0 ctx var)
                    size (comp-expr path0 ctx (get-bitstring :size bitstring)))
                {(incr-path path0)
                 ctx
                 ((cerl/ann_c_bitstr annots
                                     cerl-var
                                     size
                                     (get-bitstring :unit bitstring)
                                     (cerl/ann_c_atom annots (get-bitstring :type bitstring))
                                     (cerl/ann_make_list annots
                                                         [(cerl/ann_c_atom annots
                                                                           (get-bitstring :signedness bitstring))
                                                          (cerl/ann_c_atom annots
                                                                           (get-bitstring :endianness bitstring))]))
                  . acc1)}))
         (_
          (erlang/throw {:invalid-bitstring idx})))))))

(defn make-binary (path0 ctx form)
  (let (annots (annots-from-context [] path0 ctx))
    (case form
      ((:binary . args)
       (case (lists/foldl make-binary-element/2 {(incr-path path0) ctx []} args)
         ({_ ctx acc}
          (cerl/ann_c_binary annots (lists/reverse acc))))))))

(defn get-expr-arity (expr)
  (case (cerl/type expr)
    (:var
     (case (cerl/fname_arity expr)
       (:undefined
        -1)
       (arity (when (erlang/is_integer arity))
              arity)))
    (:fun
     (cerl/fun_arity expr))
    (_ -1)))

(defn arg-arity (args count)
  (case args
    ([]
     {[{:not-rest count}] count})
    ((:&rest . _)
     {[{:rest (+ count 1)}]  (+ count 1)})
    ((_ . rest)
     (arg-arity rest (+ count 1)))))

(defn make-let-binding (body-path0 binding-path0 ctx var expr continuation)
  (let (binding-path1 (traverse-path binding-path0)
        annots (annots-from-context [] binding-path1 ctx))
    (case expr
      ((:fn . (args . _))
       (case (arg-arity args 0)
         ({new-annots arity}
          (let (fn-annots (lists/append annots new-annots)
                cerl-var (cerl/ann_c_fname fn-annots var arity))
            (push-scope-ctx ctx)
            (add-reference-to-scope-ctx binding-path1 ctx
                                        var arity cerl-var)
            (let (cerl-expr (comp-expr (traverse-incr-path binding-path0) ctx expr)
                  cerl-body (continuation body-path0 (incr-path binding-path0) ctx))
              (pop-scope-ctx ctx)
              (cerl/ann_c_letrec annots
                                 [{cerl-var cerl-expr}]
                                 cerl-body))))))
      (_
       (let (cerl-expr (comp-expr (traverse-incr-path binding-path0)
                                  ctx
                                  expr))
         (push-scope-ctx ctx)
         (add-reference-to-scope-ctx binding-path1 ctx var
                                     (get-expr-arity cerl-expr)
                                     (cerl/ann_c_var annots var))
         (let (cerl-body (continuation  body-path0 (incr-path binding-path0) ctx))
           (pop-scope-ctx ctx)
           (cerl/ann_c_let annots
                           [(cerl/ann_c_var annots var)]
                           cerl-expr
                           cerl-body)))))))

(defn make-let-bindings (body-path0 binding-path0 ctx bindings body)
  (case bindings
    ([var expr]
     (make-let-binding body-path0 binding-path0 ctx var expr
                       (fn (body-path1 binding-path1 ctx)
                           (make-seq body-path1  ctx body))))
    ((var . (expr . rest))
     (make-let-binding body-path0 binding-path0 ctx var expr
                       (fn (body-path1 binding-path1 ctx)
                           (make-let-bindings body-path1
                                              (incr-path binding-path1)
                                              ctx rest body))))
    (_
     (erlang/throw {:invalid-let-binding
                    (idx-from-context [] binding-path0 ctx)}))))


(defn make-let (path0 ctx form)
  (let (path1 (traverse-incr-path path0))
    (case form
      ((:let . (bindings . body))
       (make-let-bindings (incr-path 2 path0) path1 ctx bindings body))
      (_
       (erlang/throw {:invalid-form (idx-from-context [] path0 ctx)})))))


(defn valid-guard (module function arity)
  (case {module function arity}
    ({:erlang :abs 1} :true)
    ({:erlang :bitsize 1} :true)
    ({:erlang :byte_size 1} :true)
    ({:erlang :element 2} :true)
    ({:erlang :float 1} :true)
    ({:erlang :hd 1} :true)
    ({:erlang :length 1} :true)
    ({:erlang :node 0} :true)
    ({:erlang :node 1} :true)
    ({:erlang :round 1} :true)
    ({:erlang :self 0} :true)
    ({:erlang :size 1} :true)
    ({:erlang :tl 1} :true)
    ({:erlang :trunc 1} :true)
    ({:erlang :tuple_size 1} :true)
    ({:erlang :is_binary 1} :true)
    ({:erlang :is_alive 0} :true)
    ({:erlang :is_boolean 1} :true)
    ({:erlang :is_function 1} :true)
    ({:erlang :is_function 2} :true)
    ({:erlang :is_integer 1} :true)
    ({:erlang :is_float 1} :true)
    ({:erlang :is_list 1} :true)
    ({:erlang :is_atom 1} :true)
    ({:erlang :is_number 1} :true)
    ({:erlang :is_pid 1} :true)
    ({:erlang :is_port 1} :true)
    ({:erlang :is_record 2} :true)
    ({:erlang :is_record 3} :true)
    ({:erlang :is_reference 1} :true)
    ({:erlang :is_tuple 1} :true)
    ({:erlang :and 2} :true)
    ({:erlang :or 2} :true)
    ({:erlang :> 2} :true)
    ({:erlang :< 2} :true)
    ({:erlang :== 2} :true)
    ({:erlang :=< 2} :true)
    ({:erlang :>= 2} :true)
    ({:erlang :/= 2} :true)
    ({:erlang :=:= 2} :true)
    ({:erlang :=/= 2} :true)
    (_ :false)))

(defn check-guards (ast)
  (case (cerl/type ast)
    (:call
     (erlang/and (valid-guard (cerl/atom_val (cerl/call_module ast))
                              (cerl/atom_val (cerl/call_name ast))
                              (cerl/call_arity ast))
                 (lists/all check-guards/1 (cerl/call_args ast))))
    (:cons
     (erlang/and (check-guards (cerl/cons_hd ast))
                 (check-guards (cerl/cons_tl ast))))
    (:binary :true)
    (:bitstring :true)
    (:tuple (lists/all check-guards/1 (cerl/tuple_es ast)))
    (:var :true)
    (:literal :true)
    (_ :false)))

(defn check-guards (idx ast)
  (case (check-guards ast)
    (:true ast)
    (:false
     (erlang/throw {:invalid-guard idx}))))


(defn make-guards (annots guards)
  (case guards
    ([]
     (cerl/ann_c_atom annots :true))
    ([guard]
     guard)
    ((pattern . rest)
     (cerl/ann_c_call annots
                      (cerl/ann_c_atom annots :erlang)
                      (cerl/ann_c_atom annots :and)
                      [pattern (make-guards annots rest)]))))

(defn make-pattern-var (path0 ctx guards0 var0)
  (let (annots (:compiler_generated .
                                    (annots-from-context [] path0 ctx)))
    (case (resolve-reference-ctx path0 ctx var0 -1)
      ({:reference {var1 _}}
       ;; The reference already exists. So we create a new variable and
       ;; add a guard for to test for equality
       (let (gensym (gensym)
             cerl-var (cerl/ann_c_var annots gensym)
             guards1 ((cerl/ann_c_call annots
                                       (cerl/ann_c_atom [:compiler_generated]
                                                        :erlang)
                                              (cerl/ann_c_atom annots
                                                               :=:=)
                                              [cerl-var (add-to-annots var1 annots)])
                      . guards0))
         ;; We don't add the generated variable to the scope as we
         ;; don't want it to be available to the user (The user really
         ;; should not even be aware of it)
         {guards1 cerl-var}))
      (_
       (let (annots-bare (annots-from-context [] path0 ctx)
                         ;; The variable is not in the scope so we turn it to a
                         ;; variable
             cerl-var (cerl/ann_c_var annots-bare var0))
         (add-reference-to-scope-ctx path0 ctx var0 -1 cerl-var)
         {guards0 cerl-var})))))

(defn make-pattern-alias (alias-path pattern-path ctx guards0 alias pattern)
  (let (alias-annots (annots-from-context [] alias-path ctx)
        pattern-annots (annots-from-context [] pattern-path ctx)
        alias-var (cerl/ann_c_var alias-annots alias))
    (case (make-pattern-element (traverse-incr-path pattern-path)
                                ctx guards0 pattern)
      ({guards1 cerl-pattern}
       (case (resolve-reference-ctx alias-path ctx alias -1)
         (:not-a-reference
          (add-reference-to-scope-ctx alias-path ctx alias -1 alias-var)
          {guards1
           (cerl/ann_c_alias alias-annots alias-var cerl-pattern)})
         (_
          (erlang/throw {:reference-already-defined alias
                                                    (idx-from-context [] alias-path ctx)})))))))

(defn make-binary-pattern-element (arg acc0)
  (case acc0
    ({path0 ctx guards0 acc1}
     (let (annots (annots-from-context [] path0 ctx)
           idx (idx-from-context [] path0 ctx))
       (case arg
         ((var . pairs0)
          (let (path1 (traverse-path path0)
                bitstring  (resolve-bitstring-defaults idx
                                                       (convert-bitstring pairs0 (new-bitstring))))
            (case (make-pattern-element path1 ctx guards0 var)
              ({guards1 cerl-var}
               (let (size (comp-expr path1 ctx (get-bitstring :size bitstring)))
                 {(incr-path path1) ctx guards1
                  ((cerl/ann_c_bitstr annots
                                      cerl-var
                                      size
                                      (get-bitstring :unit bitstring)
                                      (cerl/ann_c_atom annots (get-bitstring :type bitstring))
                                      (cerl/ann_make_list annots
                                                          [(cerl/ann_c_atom annots
                                                                            (get-bitstring :signedness bitstring))
                                                           (cerl/ann_c_atom annots
                                                                            (get-bitstring :endianness bitstring))]))
                    . acc1)})))))
         (var (when (erlang/or (erlang/is_atom var)
                               (erlang/is_integer var)))
              (let (bitstring (resolve-bitstring-defaults idx (new-bitstring)))
                (case (make-pattern-element path0 ctx guards0 var)
                  ({guards1 cerl-var}
                   (let (size (comp-expr path0 ctx (get-bitstring :size bitstring)))
                     {(incr-path path0)
                       ctx guards1
                       ((cerl/ann_c_bitstr annots
                                           cerl-var
                                           size
                                           (get-bitstring :unit bitstring)
                                           (cerl/ann_c_atom annots (get-bitstring :type bitstring))
                                           (cerl/ann_make_list annots
                                                               [(cerl/ann_c_atom annots
                                                                                 (get-bitstring :signedness bitstring))
                                                                (cerl/ann_c_atom annots
                                                                                 (get-bitstring :endianness bitstring))])) . acc1)})))))
         (_
          (erlang/throw {:invalid-bitstring idx})))))))

(defn make-binary-pattern (path0 ctx guards0 pairs)
  (case (lists/foldl make-binary-pattern-element/2
                     {(incr-path path0) ctx guards0 []} pairs)
    ({_ ctx guards1 acc}
     {guards1 (cerl/ann_c_binary (annots-from-context [] path0 ctx)
                                 (lists/reverse acc))})))

(defn make-pattern-tuple (path0 ctx guards0 args)
  (let (annots (annots-from-context [] path0 ctx))
    (case (lists/foldl (fn (arg acc0)
                           (case acc0
                             ({path1 guards1 acc1}
                              (case (make-pattern-element (traverse-path path1) ctx guards1 arg)
                                ({guards2 element}
                                 {(incr-path path1)
                                  guards2 (element . acc1)})))))
                       {path0 guards0 []} args)
      ({_ guards3 acc}
       {guards3 (cerl/ann_c_tuple annots (lists/reverse acc))}))))

(defn make-pattern-list (path0 ctx guards0 l)
  (let (annots (annots-from-context [] path0 ctx))
    (case l
      ([]
       {guards0 (cerl/c_nil)})
      ((h . t)
       (case (make-pattern-element (traverse-path path0) ctx guards0 h)
         ({guards1 cerl-h}
          (case (make-pattern-list (incr-path path0) ctx guards1 t)
            ({guards2 cerl-t}
             {guards2 (cerl/ann_c_cons annots cerl-h cerl-t)}))))))))

(defn make-literal-string (_path0 annots _ctx string)
  (cerl/ann_c_string annots string))

(defn make-pattern-element (path0 ctx guards0 arg0)
  (let (annots (annots-from-context [] path0 ctx))
    (case arg0
      (arg0 (when (erlang/is_binary arg0))
            {guards0 (cerl/ann_make_data annots {:atomic arg0} [])})
      (:_
       (let (gensym (erlang/list_to_atom (lists/append "_"
                                                       (erlang/atom_to_list (gensym))))
             cerl-var (cerl/ann_c_var annots gensym))
         (add-reference-to-scope-ctx path0 ctx gensym -1 cerl-var)
         {guards0 cerl-var}))
      (arg0 (when (erlang/is_atom arg0))
            (make-pattern-var path0 ctx guards0 arg0))
      (arg0 (when (erlang/is_integer arg0))
            {guards0 (cerl/ann_c_int annots arg0)})
      (arg0 (when (erlang/is_float arg0))
            {guards0 (cerl/ann_c_float annots arg0)})
      (args0 (when (erlang/is_tuple args0))
             (make-pattern-tuple path0 ctx guards0 (erlang/tuple_to_list args0)))
      ([:= alias pattern] (when (erlang/is_atom alias))
       (make-pattern-alias (incr-path path0) (traverse-incr-path 2 path0)
                           ctx guards0 alias pattern))
      ([:= pattern alias] (when (erlang/is_atom alias))
       (make-pattern-alias (traverse-incr-path 2 path0) (incr-path path0)
                           ctx guards0 alias pattern))
      ([:quote args]
       (let (literal (make-literal (traverse-incr-path path0) ctx args))
         {guards0 literal}))
      ([:string str0]
       (let (literal (make-literal-string (traverse-incr-path path0) annots ctx str0))
         {guards0 literal}))
      ((:binary . pairs)
       (make-binary-pattern path0 ctx guards0 pairs))
      ((:list . args)
       (make-pattern-list (incr-path path0) ctx guards0 args))
      ((:tuple . args)
       (make-pattern-tuple (incr-path path0) ctx guards0 args))
      ([arg1 :. arg2]
       (case (make-pattern-element (traverse-path path0) ctx guards0 arg1)
         ({guards1 cerl-arg1}
          (case (make-pattern-element (traverse-incr-path 2 path0)
                                      ctx guards1 arg2)
            ({guards2 cerl-arg2}
             {guards2 (cerl/ann_c_cons annots cerl-arg1 cerl-arg2)})))))
      ([:cons arg1 arg2]
       (case (make-pattern-element (traverse-incr-path path0) ctx guards0 arg1)
         ({guards1 cerl-arg1}
          (case (make-pattern-element (traverse-incr-path 2 path0)
                                      ctx guards1 arg2)
            ({guards2 cerl-arg2}
             {guards2 (cerl/ann_c_cons annots cerl-arg1 cerl-arg2)})))))
      ((var . args)
       (case (resolve-reference-ctx path0 ctx var (erlang/length args))
         ({:apply :not-rest :macro {function arity}}
          (make-pattern-element path0 ctx guards0
                                (call-macro (module-name-ctx ctx)
                                            function
                                            args)))
         ({:apply :rest :macro {function arity}}
          (make-pattern-element path0 ctx guards0
                                (call-macro (module-name-ctx ctx) function
                                            (runtime-args-to-arity args 1 arity []))))
         ({:remote :not-rest :macro {module function arity}}
          (make-pattern-element path0 ctx guards0
                                (call-macro  module function
                                             args)))
         ({:remote :rest :macro {module function arity}}
          (make-pattern-element path0 ctx guards0
                                (call-macro module function
                                            (runtime-args-to-arity args 1 arity []))))
         (_
          (let (idx (idx-from-context [] path0 ctx))
            (erlang/throw {:invalid-definition idx})))))
      (_
       (erlang/throw {:invalid-pattern (idx-from-context [] path0 ctx)})))))

(defn make-pattern-clause-body (path0 ctx form)
  (push-scope-ctx ctx)
  (let (annots (annots-from-context [] path0 ctx))
    (case form
      ((pattern . ([:when guards] . body))
       (case (make-pattern-element (traverse-path path0) ctx [] pattern)
         ({pattern-guards cerl-pattern}
          (let (guard-annots (annots-from-context []
                                                  (traverse-incr-path path0) ctx)
                guard-idx (idx-from-context [] (traverse-incr-path path0) ctx)
                cerl-guard (comp-expr (traverse-incr-path (traverse-incr-path path0)) ctx guards)
                cerl-body (make-seq (incr-path 2 path0) ctx body))
            (pop-scope-ctx ctx)
            (cerl/ann_c_clause annots
                               [cerl-pattern]
                               (check-guards guard-idx
                                             (make-guards guard-annots
                                                          (cerl-guard . pattern-guards)))
                               cerl-body)))))
      ((pattern . body)
       (case (make-pattern-element (traverse-path path0) ctx [] pattern)
         ({pattern-guards cerl-pattern}
          (let (cerl-body (make-seq (incr-path path0) ctx body))
            (pop-scope-ctx ctx)
            (cerl/ann_c_clause annots
                               [cerl-pattern]
                               (make-guards annots pattern-guards)
                               cerl-body)))))
      (_
       (erlang/throw {:invalid-case-clause (idx-from-context [] path0 ctx)})))))

(defn do-clause-terminator (path0 ctx clause)
  (let (actual-clause (make-pattern-clause-body (traverse-path path0) ctx clause)
        annots (:compiler_generated . (annots-from-context [] path0 ctx))
        var (gensym))
    {actual-clause
     [(cerl/ann_c_clause annots
                         [(cerl/ann_c_var annots var)]
                              (cerl/ann_c_primop annots
                                                 (cerl/ann_c_atom annots :match_fail)
                                                 [(cerl/ann_c_tuple annots
                                                                    [(cerl/ann_c_atom annots :case_clause)
                                                                     (cerl/ann_c_var annots var)])]))]}))

(defn make-pattern (path0 ctx form acc)
  (case form
    ([]
     (erlang/throw {:no-clauses-provided (idx-from-context [] path0 ctx)}))
    ([clause]
     (case (do-clause-terminator path0 ctx clause)
       ({clauses special-terminator}
        (lists/append (lists/reverse (clauses . acc)) special-terminator))))
    ((clause . rest)
     (let (clauses (make-pattern-clause-body (traverse-path path0) ctx clause))
       (make-pattern (incr-path path0) ctx rest (clauses . acc))))))

(defn gen-args (path0 ctx arg-list acc)
  (let (annots
        (annots-from-context :traverse path0 ctx))
    (case arg-list
      ([:&rest rest-arg]
       {(lists/reverse ((cerl/ann_c_var annots rest-arg) . acc)) :true})
      ((:&rest . rest-arg)
       (erlang/throw {:invalid-arguments (idx-from-context [] path0 ctx)}))
      ((a . rest) (when (erlang/is_atom a))
       (gen-args (incr-path path0) ctx rest ((cerl/ann_c_var annots a) . acc)))
      ([]
       {(lists/reverse acc) :false})
      (_
       (erlang/throw {:invalid-arg-list (idx-from-context [] path0 ctx)})))))

(defn make-fun-body (path0 ctx is-anon arg-list expressions)
  (let (body (make-seq (incr-path path0) ctx expressions))
    (case is-anon
      (:true
       (pop-scope-ctx ctx)
       (incr-fun-index-ctx ctx))
      (:false
       (pop-scope-ctx ctx)))
    {arg-list body}))

(defn make-rest-fun-body (path0 ctx is-anon name arg-list expressions)
  (case (make-fun-body path0 ctx is-anon arg-list expressions)
    ({arg-list body}
     (case is-anon
       (:false
        (add-rest-ctx path0 ctx name (erlang/length arg-list))
        {arg-list body})
       (:true
        (let (index (anon-fun-index-ctx ctx))
          (add-rest-ctx path0 ctx {:anon index} (erlang/length arg-list))
          {arg-list body}))))))

(defn do-function-body (path0 ctx is-anon name args0 expressions)
  (push-scope-ctx ctx)
  (let (args1 (lists/foldl (fn (el acc)
                               (let (arg (case el
                                           ([_ arg]
                                            arg)
                                           (_
                                            el)))
                                 (add-reference-to-scope-ctx path0 ctx arg -1 (cerl/c_var arg))
                                 (arg . acc)))
                           [] args0))
    (case (gen-args (traverse-path path0) ctx (lists/reverse args1) [])
      ({arg-list :true}
       (make-rest-fun-body path0 ctx is-anon name arg-list expressions))
      ({arg-list :false}
       (make-fun-body path0 ctx is-anon arg-list expressions)))))

(defn make-quasi-tuple (path0 ctx arg0)
  (let (annots  (annots-from-context [] path0 ctx)
                result (lists/foldl (fn (element acc)
                                        (case acc
                                          ({path1 acc0}
                                           (let (cerl-el (make-quasi-element (traverse-path path1) ctx element))
                                             {(incr-path path1)
                                               ( cerl-el .  acc0)}))))
                                    {path0 []} (erlang/tuple_to_list arg0)))
    (case result
      ({_ elements1}
       (cerl/ann_c_tuple annots (lists/reverse  elements1))))))

(defn make-quasi-element (path0 ctx arg0)
  (let (annots  (annots-from-context [] path0 ctx))
    (case arg0
      (arg1
       (when (erlang/is_binary arg1))
       (cerl/ann_make_data annots {:atomic arg1} []))
      (arg1
       (when (erlang/is_atom arg1))
       (cerl/ann_c_atom annots arg1))
      (arg1
       (when (erlang/is_tuple arg1))
       (make-quasi-tuple path0 ctx arg1))
      (arg1
       (when (erlang/is_integer arg1))
       (cerl/ann_c_int annots arg1))
      (arg1
       (when (erlang/is_float arg1))
        (cerl/ann_c_float annots arg1))
      ([:unquote arg1]
       (comp-expr (traverse-incr-path path0) ctx arg1))
      (arg1
       (when (erlang/is_list arg1))
       (make-quasi (traverse-path path0) ctx arg1)))))

(defn make-quasi (path0 ctx arg0)
  (let (annots  (annots-from-context [] path0 ctx))
    (case arg0
      ([]
       (cerl/ann_c_nil annots))
      (([:unquote-splicing arg1] . t)
       (let (cerl-h (comp-expr (traverse-incr-path (traverse-path path0)) ctx arg1)
             cerl-t (make-quasi (incr-path path0) ctx t))
         (cerl/ann_c_call annots
                          (cerl/ann_c_atom annots :lists)
                          (cerl/ann_c_atom annots :append)
                          [cerl-h cerl-t])))
      ((h . t)
       (let (cerl-h (make-quasi-element (traverse-path path0) ctx h)
             cerl-t (make-quasi (incr-path path0) ctx t))
         (cerl/ann_c_cons annots
                          cerl-h
                          cerl-t)))
      (else
       (make-quasi-element path0 ctx else)))))

(defn comp-expr (path0 ctx form)
  (let (annots (annots-from-context [] path0 ctx))
    (case form
      (arg (when (erlang/is_binary arg))
           (cerl/ann_make_data annots {:atomic arg} []))
      (arg (when (erlang/is_integer arg))
           (cerl/ann_c_int annots arg))
      (arg (when (erlang/is_float arg))
           (cerl/ann_c_float annots arg))
      (arg (when (erlang/is_atom arg))
           (case (resolve-reference-ctx path0 ctx arg -1)
             ({:reference {var _}}
              (add-to-annots var annots))
             (e
              (let (idx (idx-from-context [] path0 ctx))
                (erlang/throw {:invalid-reference e arg idx})))))
      (arg (when (erlang/and
                  (erlang/is_tuple arg)
                  (== (erlang/element 1 arg) :--fun)))
           (make-fun path0 ctx form))
      (arg (when (erlang/is_tuple arg))
           (make-tuple-expr path0 ctx (erlang/tuple_to_list arg)))
      ((:let . _)
       (make-let path0 ctx form))
      ((:case . (expr . clauses))
       (let (cerl-expr (comp-expr (traverse-incr-path path0) ctx expr)
             cerl-clauses (make-pattern (incr-path 2 path0) ctx clauses []))
         (cerl/ann_c_case annots cerl-expr cerl-clauses)))
      ((:do . args)
       (make-seq (incr-path path0) ctx args))
      ((:binary . _)
       (make-binary path0 ctx form))
      ([arg1 :. arg2]
       (make-cons annots (traverse-path path0) (traverse-incr-path 2 path0)
                  ctx arg1 arg2))
      ([:cons arg1 arg2]
       (make-cons annots (incr-path path0) (incr-path 2 path0) ctx arg1 arg2))
      ((:apply . _)
       (make-apply path0 ctx form))
      ([:quote args]
       (make-literal (traverse-incr-path path0) ctx args))
      ([:quasiquote args]
       (make-quasi (traverse-incr-path path0) ctx args))
      ([:string args]
       (make-literal-string (traverse-incr-path path0) annots ctx args))
      ((:list . args)
       (make-list (incr-path path0) ctx args))
      ((:tuple . args)
       (make-tuple-expr (incr-path path0) ctx args))
      ((:__try . _)
       (make-try path0 ctx form))
      ((:fn . fn-body)
       (case fn-body
         ((args . expression)
          (case (do-function-body (incr-path path0) ctx :true :anon args expression)
            ({arg-list body}
             (cerl/ann_c_fun annots arg-list body))
            (_
             (erlang/throw {:invalid-fn-form (idx-from-context [] path0 ctx)}))))))
      ((val . args)
       (make-call path0 ctx val args :false))
      (_
       (erlang/throw {:invalid-fn-form (idx-from-context [] path0 ctx)})))))

(defn default-type ()
  [{:--fun :erlang :any}])

(defn make-spec-tuple (line path0 ctx form)
  (case (lists/foldl (fn (el acc0)
                         (case acc0
                           ({path1 acc1}
                            (let (comp-el (comp-spec-expr path1 ctx el))
                              {(incr-path path1) (comp-el . acc1)}))))
                     {path0 []} (erlang/tuple_to_list form))
    ({_ tuple-values}
     {:tuple line (erlang/list_to_tuple (lists/reverse tuple-values))})))

(defn comp-spec-args (line ctx args)
  (let (comp-args (lists/foldl (fn (el acc)
                                   (add-type-reference-to-scope-ctx ctx el -1)
                                   ({:var line el} . acc))
                               [] args))
  (lists/reverse comp-args)))

(defn def-anon-function-spec (path0 ctx args0 expr0)
  (let (line1 (case (idx-from-context [] path0 ctx)
                ({line0 _}
                 line0)))
    (push-type-scope-ctx ctx)
    (let (args1 (comp-spec-args path0 (push-type-scope-ctx ctx) args0)
          expr1 (comp-spec-expr (incr-path 2 path0) ctx expr0))
      (pop-type-scope-ctx ctx)
      [{:type line1 :fun
              [{:type line1 :product (lists/reverse args1)}
               expr1]}])))

(defn comp-binary-spec (line1 path0 ctx form)
  (case form
    ([:binary]
     {:type line1 :binary [{:integer line1 0} {:integer line1 0}]})
    ([:binary arg]
     (when (erlang/is_integer arg))
     {:type line1 :binary [{:integer line1 arg} {:integer line1 0}]})
    ([:binary :* arg]
     (when (erlang/is_integer arg))
     {:type line1 :binary [{:integer line1 0} {:integer line1 arg}]})
    ([:binary arg1 :* arg2]
     (when (erlang/and (erlang/is_integer arg1)
                       (erlang/is_integer arg2)))
     {:type line1 :binary [{:integer line1 arg1} {:integer line1 arg2}]})
    (_
     (let (idx (idx-from-context [] path0 ctx))
       (erlang/throw {:invalid-binary-type-spec idx})))))

(defn comp-function-spec (line1 path0 ctx form)
  (case form
    ([:fn]
     {:type line1 :fun []})
    ([:fn [:...] expr]
     (let (cerl-expr (comp-expr (traverse-incr-path 2 path0) ctx expr))
       {:type line1 :fun [{:type line1 :any} cerl-expr]}))
    ([:fn args expr]
     (def-anon-function-spec (incr-path path0) ctx args expr))))

(defn comp-type-call-spec (line path0 ctx form)
  (case form
    ([{:--fun :erlang :range} a1 a2]
     (when (erlang/and (erlang/is_integer a1)
                       (erlang/is_integer a2)))
     (let (comp-args (comp-spec-args (incr-path path0) ctx [a1 a2]))
       {:type line :range
              comp-args}))
    (({:--fun :erlang func} . args)
     ;; Things in erlang get treated a bit differently then things in
     ;; other modules. It sucks that they have to be special
     {:type line func (comp-spec-args (incr-path path0) ctx args)})
    (({:--fun module func} . args)
     (when (erlang/and (erlang/is_atom module)
                       (erlang/is_atom func)))
     {:remote_type line [{:atom line module}
                         {:atom line func}
                         (comp-spec-args (incr-path path0) ctx args)]})))

(defn make-spec-literal (path0 ctx arg0)
  (let (line1 (case (idx-from-context [] path0 ctx)
                ({line0 _}
                 line0)))
    (case arg0
      (arg1
       (when (erlang/is_atom arg1))
       {:atom line1 arg1})
      (arg1
       (when (erlang/is_integer arg1))
       {:integer line1 arg1})
      ([args]
       {:list line1 (make-spec-literal (traverse-path path0) ctx args)})
      (arg1
       (when (erlang/is_list arg1))
       (let (specs (lists/foldl (fn (el acc0)
                                    (case acc0
                                      ({path1 acc1}
                                       {(incr-path path1)
                                        ((make-spec-literal path1 ctx el) .  acc1)})))
                                {path0 []} arg1))
         {:list line1 (lists/reverse specs)}))
      (arg1
       (when (erlang/is_tuple arg1))
       (let (specs (lists/foldl (fn (el acc0)
                                    (case acc0
                                      ({path1 acc1}
                                       {(incr-path path1)
                                        ((make-spec-literal path1 ctx el) .  acc1)})))
                                {path0 []} (erlang/tuple_to_list arg1)))
         {:tuple line1 (lists/reverse specs)}))
      (_
       (let (idx (idx-from-context [] path0 ctx))
         (erlang/throw {:invalid-type-literal idx}))))))

(defn comp-spec-expr (path0 ctx form)
  (let (line1 (case (idx-from-context [] path0 ctx)
                ({line0 _}
                 line0)))
    (case form
      ([:quote value]
       (make-spec-literal (traverse-incr-path path0) ctx value))
      (arg
       (when (erlang/is_tuple arg))
       (make-spec-tuple line1 path0 ctx form))
      (arg
       (when (erlang/is_integer arg))
       (make-spec-literal path0 ctx arg))
      ((:binary . _)
       (comp-binary-spec line1 path0 ctx form))
      ((:fn . _)
       (comp-function-spec line1 path0 ctx form))
      (({:--fun _ _} . _)
       (comp-type-call-spec line1 path0 ctx form))
      ([:list arg]
       {:list line1
              (comp-spec-expr (traverse-incr-path path0) ctx arg)})
      (name
       (when (erlang/is_atom name))
       (case (resolve-type-reference-ctx ctx name -1)
         (:true
          {:var line1 name})
         (:false
          (let (idx (idx-from-context []  path0 ctx))
            (erlang/throw {:invalid-type-reference name idx})))))
      ((var . args)
       (let (arg-count (erlang/length args))
         (case (resolve-type-reference-ctx ctx var arg-count)
           (:false
            (let (idx (idx-from-context [] path0 ctx))
              (erlang/throw {:invalid-type-reference var idx})))
           (:true
            {:type line1 var
                   (comp-spec-args (incr-path path0) ctx args)}))))
      (_
       (let (idx (idx-from-context [] path0 ctx))
         (erlang/throw {:invalid-type-reference idx}))))))

(defn rewrite-spec-args (args acc)
  (case args
    ((:&rest . arg)
     (lists/reverse  ([arg] . acc)))
    ([]
     (lists/reverse acc))
    ((arg . rest)
     (rewrite-spec-args rest (arg . acc)))))

(defn comp-implicit-spec (path0 ctx name args expr)
  (let (annots (annots-from-context [] path0 ctx)
        arity (erlang/length args)
        is-rest (lists/member :&rest args)
        new-args (case is-rest
                   (:true
                    (rewrite-spec-args args []))
                   (:false
                    args)))
    (case is-rest
      (:true
       (add-rest-ctx path0 ctx name (erlang/length new-args)))
      (:false ctx))
    (let (body (def-anon-function-spec (incr-path 2 path0) ctx args expr))
      (add-type-ctx ctx name arity {{:c_literal annots :spec}
                                    {:c_literal annots [{{name arity}
                                                         [body]}]}}))))

(defn def-top-level-function-spec (path0 ctx name args expression)
  (let (line1 (case (idx-from-context [] path0 ctx)
                ({line0 _}
                 line0))
              arity (erlang/length args))
    (push-type-scope-ctx ctx)
    (add-type-reference-to-scope-ctx ctx name arity)
    (lists/foreach (fn (arg0)
                       (case arg0
                         (arg1 (when (erlang/is_atom arg1))
                               (add-type-reference-to-scope-ctx
                                ctx arg1 -1))
                         (_
                          (let (idx (idx-from-context [] path0 ctx))
                            (erlang/throw {:invalid-type-definition
                                           idx})))))
                   args)
    (let (expr (comp-spec-expr (incr-path 3 path0) ctx expression))
      (pop-type-scope-ctx ctx)
      (add-type-ctx ctx name arity {{:c_literal [line1] :type}
                                    {:c_literal [line1]
                                                [{name expr
                                                       (lists/map
                                                        (fn (el)
                                                            {:var line1 el})
                                                        args)}]}}))))

(defn comp-spec (path0 ctx form)
  (case form
    ([:deftype+ name args expression]
     (when (erlang/and (erlang/is_atom name)
                       (erlang/is_list args)))
     (let (arity (erlang/length args))
       (add-type-export-ctx ctx name arity)
       (def-top-level-function-spec (incr-path path0) ctx name args expression)))
    ([:deftype name args expression]
     (when (erlang/and (erlang/is_atom name)
                       (erlang/is_list args)))
     (comp-implicit-spec (incr-path path0) ctx name args expression))
    ([:defspec name args expression]
     (comp-implicit-spec (incr-path path0) ctx name args expression))
    (_
     (let (idx (idx-from-context [] path0 ctx))
       (erlang/throw {:invalid-type-definition idx})))))

(defn comp-function1 (path0 ctx return-type name args expressions)
  (let (spec-args (lists/map (fn (arg)
                                 (case arg
                                   ([spec-arg _]
                                    spec-arg)
                                   (_
                                    (default-type)))) args))
    (comp-implicit-spec path0 ctx name spec-args return-type)
    (case (do-function-body (incr-path path0) ctx :false name args expressions)
      ({arg-list body}
       {name arg-list body}))))

(defn comp-function (path0 ctx form)
  (case form
    ((return-type . (name . (args . expressions)))
     (when (erlang/and (erlang/is_atom name)
                       (erlang/is_list args)))
     (comp-function1 (incr-path path0) ctx return-type name args expressions))
    ((name . (args . expressions))
     (when (and (erlang/is_list args)
                (erlang/is_atom name)))
     (comp-function1 path0 ctx (default-type) name args expressions))
    (_
     (erlang/throw {:invalid-definition (idx-from-context [] path0 ctx)}))))


(defn+ comp-definition (path0 ctx form)
  (let (annots (annots-from-context :traverse  path0 ctx))
    (case form
      ((:defn+ . details)
       (case (comp-function (incr-path path0) ctx details)
         ({name arg-list body}
          (add-exported-def-ctx path0 ctx annots name arg-list body))))
      ((:defn . details)
       (case (comp-function (incr-path path0) ctx details)
         ({name arg-list body}
          (add-def-ctx path0 ctx annots name arg-list body))))
      ((:definline . details)
       (let (inline-annots (:inline . annots))
         (case (comp-function (incr-path path0) ctx details)
           ({name arg-list body}
            (add-def-ctx path0 ctx annots name arg-list body)))))
      ((:defmacro+ . details)
       (case (comp-function (incr-path path0) ctx details)
         ({name arg-list body}
          (add-exported-def-ctx path0 ctx annots name arg-list body)
          (add-macro-ctx ctx name (erlang/length arg-list) path0))))
      ((:defmacro . details)
       (case (comp-function (incr-path path0) ctx details)
         ({name arg-list body}
          ;; Initially all macros have to be exported, since the
          ;; caller is the compiler and not the module
          ;; itself. However, we keep a list of macros that need to be
          ;; hidden so that after the fact we can roll through the
          ;; list unexporting things that do not need to be exported.
          (add-exported-def-ctx path0 ctx annots name arg-list body)
          (add-unexported-macro-ctx path0 ctx name (erlang/length arg-list)))))
      ((:deftype+ . _)
       (comp-spec path0 ctx form))
      ((:deftype . _)
       (comp-spec path0 ctx form))
      ((:defspec . _)
       (comp-spec path0 ctx form))
      ((var . args)
       (case (resolve-reference-ctx path0 ctx var (erlang/length args))
         ({:apply :not-rest :macro {function arity}}
          (make-forms path0 ctx
                     (call-macro (module-name-ctx ctx) function args)))
         ({:apply :rest :macro {function arity}}
          (make-forms path0 ctx
                     (call-macro (module-name-ctx ctx) function
                                 (runtime-args-to-arity args 1 arity []))))
         ({:remote :not-rest :macro {module function arity}}
          (make-forms path0 ctx
                     (call-macro  module function
                                  args)))
         ({:remote :rest :macro {module function arity}}
          (make-forms path0 ctx
                     (call-macro module function
                                 (runtime-args-to-arity args 1 arity []))))
         (_
          (let (idx (idx-from-context [] path0 ctx))
            (erlang/throw {:invalid-definition idx})))))
      (_
       (let (idx (idx-from-context [] path0 ctx))
         (erlang/throw {:invalid-definition idx}))))))

(defn make-literal-list (path0 annots ctx list)
  (case list
    ([] (cerl/c_nil))
    ((h . t)
     (cerl/ann_c_cons annots
                      (make-literal (traverse-path path0) ctx h)
                      (make-literal-list (incr-path path0) annots ctx t)))))

(defn make-literal-tuple (path0 annots ctx elements0)
  (let (result (lists/foldl (fn (element acc)
                                (case acc
                                  ({path1 acc0}
                                   (let (acc1 ((make-literal (traverse-path path1) ctx element) .  acc0)
                                         path2 (incr-path path1))
                                     {path2 acc1}))))
                            {path0 []} elements0))
    (case result
      ({_ elements1}
       (cerl/ann_c_tuple annots elements1)))))

(defn make-literal (path0 ctx arg0)
  (let (annots  (annots-from-context [] path0 ctx))
    (case arg0
      (arg1
       (when (erlang/is_binary arg1))
       (cerl/ann_make_data annots {:atomic arg1} []))
      (arg1
       (when (erlang/is_atom arg1))
       (cerl/ann_c_atom annots arg1))
      (arg1
       (when (erlang/is_tuple arg1))
       (make-literal-tuple path0 annots ctx arg1))
      (arg1
       (when (erlang/is_integer arg1))
       (cerl/ann_c_int annots arg1))
      (arg1
       (when (erlang/is_float arg1))
       (cerl/ann_c_float annots arg1))
      ([:string str1]
       (make-literal-string (traverse-incr-path path0) annots ctx str1))
      (arg1
       (when (erlang/is_list arg1))
       (make-literal-list path0 annots ctx arg1)))))

;; Compilation Infrastructure
;; -------------------------
;;
;; The following functions comprise most of the UI for the Joxa
;; compiler. Organizing the compilation and adding various metadata
;; functions.

(defn+ make-forms (path0 ctx form0)
  (case form0
    ((:do . rest)
     (lists/foldl (fn (form1 path1)
                      (make-forms path1 ctx form1)
                      (incr-path path1))
                  (traverse-incr-path path0)  rest))
    ((:module . _)
     (comp-module path0 ctx form0))
    (_
     (comp-definition path0 ctx form0))))

(defn print-erl-errors-or-warnings (errs)
  (lists/foreach (fn (err)
                     (case err
                       ({file sub-errors}
                        (lists/foreach
                         (fn (sub-err)
                             (case sub-err
                               ({line module error-descriptor}
                                (let (p-fun (erlang/make_fun module :format_error 1))
                                  (io/format "~s:~i ~s~n" [file line (p-fun error-descriptor)])))))
                         sub-errors))))
                 errs))

(defn erl-comp (ctx cerl-ast type)
  (case type
    (:final
     (case (lists/member :to_core (options-ctx ctx))
       (:true
        [(core_pp/format cerl-ast) \\n])
       (:false
        (case (lists/member :to_ast (options-ctx ctx))
          (:true
           (io_lib/format "~p" [cerl-ast]))
          (_
           (case (compile/forms cerl-ast
                                (lists/append (options-ctx ctx)
                                              [:from_core
                                               :binary
                                               :return_errors
                                               :return_warnings]))
             ({ok [] result []}
              result)
             ({ok errors result warnings}
              (print-erl-errors-or-warnings errors)
              (print-erl-errors-or-warnings warnings)
              result)
             ({error errors warnings}
              (print-erl-errors-or-warnings errors)
              (print-erl-errors-or-warnings warnings)
              (erlang/throw :error))))))))
    (_
     (case (compile/forms cerl-ast [:debug_info
                                    :from_core
                                    :return_errors
                                    :return_warnings
                                    :binary])
       ({ok [] result []}
        result)
       ({ok errors result warnings}
        (print-erl-errors-or-warnings errors)
        (print-erl-errors-or-warnings warnings)
        result)
       ({error errors warnings}
        (print-erl-errors-or-warnings errors)
        (print-erl-errors-or-warnings warnings)
        (erlang/throw :error))))))

(defn get-context-exports (ctx)
  (lists/map (fn (el)
                 (case el
                   ({fun arity annots}
                    (cerl/ann_c_fname annots fun arity))))
             (sets/to_list (exports-ctx ctx))))

(defn get-definitions (ctx)
  (lists/map (fn (el)
                 (case el
                   ({_ value}
                    value)))
             (definitions-ctx ctx)))

;; ### make-joxa-info-1 Function Set
;;
;; The make-joxa-info-1 set of functions creates a module level
;; function that returns information sigficant to the joxa compilation
;; system for each function. This set of functions builds a function,
;; that if written in normal joxa would look like.
;;
;;    (defn __joxa_info (type)
;;        (case type
;;              (:rest
;;                   <rest-info>...)
;;              (:macro
;;                   <macro-info>...)))
;;
;; more may be added to this over time.
;; at the moment the <rest-info> looks as follows
;;
;; [{<fun-id> <restish-arity>}]
;;
;; Where <fun-id> is either the name of the function if it is a named
;; module level function. Or the tuple {:anon index} in the case of an
;; anonymous function where the index is the index of the fun in the
;; modules function table.
;;
;; macros follow a similar senario with the exception that there are
;; currently no anonymous macros. so macros are defined by function
;; name and return :true or :false depending on if the function is a
;; macro.
;;
(defn make-joxa-info-rest-1 (ctx)
  (let (annots [:compiler_generated]
        rests (rests-ctx ctx))
    (cerl/ann_c_clause [:compiler_generated]
                       [(cerl/ann_c_atom annots :rest)]
                       (cerl/ann_c_atom annots :true)
                       (cerl/ann_make_data annots
                                           {:atomic rests} []))))

(defn make-joxa-info-macro-1 (ctx)
  (let (annots [:compiler_generated]
        macros (macros-ctx ctx))
    (cerl/ann_c_clause [:compiler_generated]
                       [(cerl/ann_c_atom annots :macro)]
                       (cerl/ann_c_atom annots :true)
                       (cerl/ann_make_data annots
                                           {:atomic macros} []))))
(defn make-joxa-info-1 (ctx)
  (let (annots [:compiler_generated]
        clauses [(make-joxa-info-rest-1 ctx)
                 (make-joxa-info-macro-1 ctx)]
        detail-var (gensym)
        var-name (cerl/c_var detail-var))
    (add-exported-def-ctx (new-path) ctx
                          annots :--joxa-info
                          [var-name]
                          (cerl/ann_c_case annots
                                           var-name
                                           clauses)
                          :replace)))

;; ### make-joxa-info-2 function set.
;;
;; The make-joxa-info-2 functions are similar to the
;; make-joxa-info-1. However, they also take a function id as well as
;; the type. this allows you to get information about a specific
;; function. if written in normal joxa would look like.
;;
;;    (defn __joxa_info (type fun-id)
;;        (case type
;;              (:rest
;;                 (case fun-id
;;                     <fun-clauses>...))
;;              (:macro
;;                 (case fun-id
;;                     <macro-clauses>...))
;;
;; more may be added to this over time.
;;
;; In this case the fun and macro clauses provide the same information
;; as the single arg __joxa_info function, however just for the
;; function specifid.
;;
(defn make-joxa-info-rest-2 (fun-var ctx)
  (let (annots [:compiler_generated]
        rests (rests-ctx ctx)
        catch-all-var (cerl/ann_c_var [:compiler_generated] (gensym)))
    (cerl/ann_c_case annots
                     fun-var
                     (lists/append
                      (lists/map (fn (rest-el)
                                     (case rest-el
                                       ({fun-id, value}
                                        (cerl/ann_c_clause annots
                                                           [(cerl/ann_make_data annots
                                                                                {:atomic fun-id} [])]
                                                           (cerl/ann_c_atom annots :true)
                                                           (cerl/ann_make_data annots
                                                                               {:atomic value} [])))))
                                 rests)
                      [(cerl/ann_c_clause annots
                                         [catch-all-var]
                                         (cerl/ann_c_atom annots :true)
                                         (cerl/ann_c_atom annots :false))]))))

(defn make-joxa-info-macro-2 (fun-var ctx)
  (let (annots [:compiler_generated]
       macros (macros-ctx ctx)
       catch-all-var (cerl/ann_c_var [:compiler_generated] (gensym)))
    (cerl/ann_c_case annots
                     fun-var
                     (lists/append
                      (lists/map (fn (macro-el)
                                     (cerl/ann_c_clause annots
                                                        [(cerl/ann_make_data annots
                                                                             {:atomic macro-el} [])]
                                                        (cerl/ann_c_atom annots :true)
                                                        (cerl/ann_c_atom annots :true)))
                                 macros)
                      [(cerl/ann_c_clause annots
                                          [catch-all-var]
                                          (cerl/ann_c_atom annots :true)
                                          (cerl/ann_c_atom annots :false))]))))
(defn make-joxa-info-2 (ctx)
  (let (annots [:compiler_generated]
        type-var (cerl/c_var (gensym))
        fun-id-var (cerl/c_var (gensym))
        rest-clause (cerl/ann_c_clause annots
                                       [(cerl/ann_c_atom annots :rest)]
                                       (cerl/ann_c_atom annots :true)
                                       (make-joxa-info-rest-2 fun-id-var ctx))
        macro-clause (cerl/ann_c_clause annots
                                        [(cerl/ann_c_atom annots :macro)]
                                        (cerl/ann_c_atom annots :true)
                                        (make-joxa-info-macro-2  fun-id-var ctx))

        clauses [rest-clause macro-clause])

    (add-exported-def-ctx (new-path) ctx
                          [:compiler_generated] :--joxa-info
                          [type-var fun-id-var]
                          (cerl/ann_c_case [:compiler_generated]
                                           type-var
                                           clauses)
                          :replace)))

(defn make-joxa-info (ctx)
  (make-joxa-info-1 ctx)
  (make-joxa-info-2 ctx))

(defn comp-module-info (ctx)
  (let (module-name (cerl/c_atom (module-name-ctx ctx))
        argless-body (cerl/c_call (cerl/c_atom :erlang)
                                  (cerl/c_atom :get_module_info)
                                  [module-name])
        detail-var (gensym)
        var-name (cerl/c_var detail-var)
        arg-body (cerl/c_call (cerl/c_atom :erlang)
                              (cerl/c_atom :get_module_info)
                              [module-name var-name]))
    (add-exported-def-ctx (new-path) ctx
                          [:compiler_generated] :module_info []
                          argless-body
                          :replace)
    (add-exported-def-ctx (new-path) ctx
                          [:compiler_generated] :module_info
                          [var-name] arg-body :replace)))

(defn compile-types (ctx)
  (let (exported-types (sets/to_list (type-exports-ctx ctx))
        all-types (ec_dictionary/to_list (types-ctx ctx)))
    ({(cerl/c_atom :export_type) (cerl/make_data {:atomic exported-types} [])} .
     (lists/map (fn (el)
                    (case el
                      ({_ attr}
                       attr))) all-types))))

(defn sort-fun-deps (dep state)
  (case state
    ({unresolved0 resolved0}
     (case (sets/is_element dep resolved0)
       (:true
        state)
       (:false
        {(sets/add_element dep unresolved0) resolved0})))))

(defn has-errors-or-warnings? (ctx)
  (erlang/or (erlang/> (warning-count-ctx ctx) 0)
             (erlang/> (error-count-ctx ctx) 0)))

(defn has-unresolved-dependencies? (ctx)
  (let (reqs (get-definitions ctx)
        result (lists/foldl
                (fn (el acc)
                    (case el
                      ({var _ deps}
                       (case acc
                         ({unresolved0 resolved0}
                          (let (element {(cerl/fname_id var) (cerl/fname_arity var)}
                                resolved1 (sets/add_element element resolved0)
                                unresolved1 (sets/del_element element unresolved0))
                            (lists/foldl sort-fun-deps/2 {unresolved1 resolved1} (sets/to_list deps))))))))
                {(sets/new) (sets/new)} reqs))
    (case result
      ({unresolved _}
       (erlang/> (sets/size unresolved) 0)))))

(defn compilable? (ctx)
  (erlang/not (erlang/or (has-unresolved-dependencies? ctx)
                          (has-errors-or-warnings? ctx))))

(defn post-process-macros (ctx)
  (let (unexported-macros (unexported-macros-ctx ctx)
        exports0 (exports-ctx ctx)
        exports1 (sets/filter (fn (export)
                                  (case export
                                    ({fun arity _}
                                     (erlang/not (lists/member {fun arity}
                                                               unexported-macros)))))
                              exports0))
    (exports-ctx ctx exports1)))


(defn format-detail (message)
  (case message
    (_
     (io_lib/format "~p" [message]))))

;; The goal with compiler messages to print them out in a well
;; understood format. Taking the approach specified by the GNU Coding
;; standards and understood by emacs makes good sense.
;;
;;     sourcefile:lineno:column: message
;;
;; http://www.gnu.org/prep/standards/html_node/Errors.html
(defn print-compiler-message (type message)
  (case message
    ({detail {file-name {line column}}}
     (io/format "~s:~i:~i *~p* ~s~n" [file-name line column type (format-detail detail)]))
    (msg
     (io/format "UNKNOWN_TYPE ~p~n" [msg]))))

(defn report-errors-warnings (ctx)
  (let (warnings (warnings-ctx ctx)
        errors (errors-ctx ctx))
    (lists/foreach (fn (message)
                       (print-compiler-message :warning message))
                   warnings)
    (lists/foreach (fn (message)
                       (print-compiler-message :warning message))
                   errors)))

(defn post-processing (compile-type ctx)
  (case compile-type
    (:final
     (post-process-macros ctx)
     (report-errors-warnings ctx))
    (_
     :ok)))

(defn+ compile-context (ctx compile-type)
  (case (compilable? ctx)
    (:true
     (post-processing compile-type ctx)
     (comp-module-info ctx)
     (make-joxa-info ctx)
     (let (annots (line-ctx ctx)
           module-name (cerl/ann_c_atom annots
                                        (module-name-ctx ctx))
           exports (get-context-exports ctx)
           attrs (lists/append (attrs-ctx ctx)
                               (compile-types ctx))
           defs (lists/map (fn (def)
                               (case def
                                 ({var body _}
                                  {var body})
                                 (else
                                  (erlang/throw else))))
                           (get-definitions ctx)))
       (erl-comp ctx (cerl/ann_c_module annots module-name exports attrs defs)
                 compile-type)))
    (:false
     (when (erlang/== compile-type :final))
     (erlang/throw :unresolved-function-dependencies))
    (:false
     (report-errors-warnings ctx)
     :uncompilable)))

(defn parse-all (file-name input acc)
  (case (has-more-data-to-parse input)
    (:false
     (case input
       ({:parse-output _ _ annots _}
        {annots  (lists/reverse acc)})))
    (:true
     (case (parse file-name input)
       ({annots ast0 rest}
        (parse-all file-name rest (ast0 . acc)))))))

(defn convert-options (options acc)
  (case options
    (({:to-core :true} . tail)
     (convert-options tail (:to_core . acc)))
    (({:ast :true} . tail)
     (convert-options tail (:to_ast . acc)))
    (({:debug-info :true} . tail)
     (convert-options tail (:debug_info . acc)))
    ([]
     acc)
    ((_ . tail)
     (convert-options tail acc))))

(defn bootstrap-comp (ctx file-name options binary)
  (case (parse-all file-name binary [])
    ({annots ast}
     (set-context-all-ctx ctx
                      [{:options (convert-options options [])}
                       {:annots annots}])
     (lists/foldl (fn (def path)
                      (make-forms (traverse-path path)
                                  ctx def)
                      (incr-path path))
                  (new-path)  ast)
     (compile-context ctx :intermediate))))

(defn should-load? (options)
  (case (proplists/get_value :ast options)
    (:undefined
     (case (proplists/get_value :to-core options)
       (:undefined :true)
       (_ :false)))
    (_
     :false)))

(defn do-final-comp (file-name options ctx)
  (case  (compile-context ctx :final)
    (:uncompilable
     (erlang/throw :unresolved-function-dependencies))
    (module-binary
     (case (should-load? options)
       (:true
        (let (module-name (module-name-ctx ctx)
             load-result (code/load_binary module-name file-name module-binary))
          (case load-result
            ({:module module-name}
             (let (raw-ctx (get-raw-context ctx))
               {raw-ctx module-binary}))
            (_
             (erlang/throw {:unable-to-load file-name})))))
       (:false
        module-binary)))))

(defn+ bootstrap-comp (file-name options)
  (case (start-context)
    ({:ok ctx}
     (case (file/read_file file-name)
       ({:ok binary}
        (case (bootstrap-comp ctx file-name options binary)
          (:uncompilable
           (erlang/throw :unresolved-function-dependencies))
          (_
        (do-final-comp file-name options ctx))))
       ({:error reason}
        (erlang/throw {:file-access reason file-name})))
     (stop-context ctx))))

(defn internal-forms (file-name input ctx binary)
  (case (has-more-data-to-parse input)
    (:false
     :ok)
    (:true
     (case (parse file-name input)
       ({annots ast0 (= rest {:parse-output _ path _ _})}
        (annots-ctx ctx annots)
        (make-forms (traverse-path path) ctx ast0)
        (case (compile-context ctx :intermediate)
          (:uncompilable
           (internal-forms file-name rest ctx :uncompilable))
          (binary1
           (let (module-name (module-name-ctx ctx))
             (case (code/load_binary module-name file-name binary1)
               ({:module module-name}
                (internal-forms file-name rest ctx binary1))
               (_
                (erlang/throw {:unable-to-load file-name})))))))))))

(defn+ forms (file-name binary options)
  (case (start-context)
    ({:ok ctx}
     (set-context-all-ctx ctx [{:options (convert-options options [])}])
     (internal-forms file-name binary ctx <<>>)
     (do-final-comp file-name options ctx))))

(defn+ forms (binary options)
  (forms "" binary options))

(defn get-extension (options)
  (case (proplists/get_value :ast options)
    (:false
     (case (proplists/get_value :to-core options)
       (:false
        ".beam")
       (_
        ".core")))
    (_
     ".ast")))

(defn save-output (options binary ctx)
  (let (out-dir (proplists/get_value :outdir options :undefined))
    (case out-dir
      (:undefined
       :ok)
      (out-dir
       (let (module-name (get-context :module-name ctx)
             path (re/split (erlang/atom_to_list  module-name) "\\.")
             out-path (filename/join (out-dir . path))
             out-file (lists/flatten ((erlang/binary_to_list out-path)
                                      . (get-extension options))))
         (filelib/ensure_dir out-path)
         (file/write_file out-file binary))))))

(defn+ do-compile (file-name options)
  (let (result
        (case (proplists/get_value :bootstrap options :false)
          (:true
           (bootstrap-comp file-name options))
          (:false
           (case (file/read_file file-name)
             ({:ok binary}
              (forms file-name binary options))
             ({:error reason}
              (erlang/throw {:file-access reason file-name}))))))
    (case result
      ({ctx binary}
       (save-output options binary ctx)
       result))))

;; Command Line Interface
;; ----------------------
;;
;; This set of functions represents the command line interface and its
;; description to Joxa.
;;
(defn usage (os-list)
  (getopt/usage os-list "" "[option1 option2 ...] <joxa-file>"
                '()))

(defn+ option-spec-list ()
  [{:ast \a "ast" {:boolean :false} "compile to core ast"}
   {:to-core \c "to-core" {:boolean :false} "compile to core erlang"}
   {:outdir \o "outdir" {:string "./"} "the directory to output beam files"}
   {:bootstrap \b "bootstrap" {:boolean :false}
               "Use the special limited bootstrap compiler"}])

(defn+ main (args)
  (case
      (getopt/parse (option-spec-list) args)
    ({:ok {options [target]}}
     (do-compile target options))
    (_
     (usage (option-spec-list))
     :did-not-get-it)))

(defn+ main ()
  (main (init/get_plain_arguments)))