;;; The Joxa Compiler
;;; =================
;;; *author: Eric Merritt*
;;; *copyright: Erlware, LLC 2011 - 2012
;;;
;;; This provides the base compiler for the Joxa language. Due to the
;;; way code loading works on the Erlang VM it needs to be all in the
;;; same module, using no macros or external Joxa resources. While
;;; this severely restricts the syntax you can use in the compler, it
;;; does ensure that only a very minimal base language is supported.
(module joxa.compiler
        (require init getopt file
                 lists unicode sets
                 re ets proplists filename
                 ec_dictionary ec_lists
                 filelib file cerl code core_pp
                 compile io io_lib
                 crypto binary)
        (use (erlang :only (+/2
                            ==/2
                            and/2
                            or/2
                            is_list/1
                            is_binary/1))))

;; The Lexer and Parser
;; --------------------
;;
;; The parser for Joxa is a [Parsing Expression
;; Grammer](http://en.wikipedia.org/wiki/Parsing_expression_grammar)3
;; based heavily on the Neotoma project. It provides two classes of
;; parse functions. The first set of parse functions are prefixed by a
;; 'p-' and are low level constructor functions that are not part of
;; the Joxa grammer. The second set are parsing functions that are not
;; prefixed with a 'p-' and represent parts of the Joxa grammer it
;; self. These are public because it is expected that they will be
;; used for reader macros.

(deftype index () {(erlang/non_neg_integer)
                   (erlang/non_neg_integer)})

(defn+ line (index)
  (case index
    ({l _}
     l)))

(defn+ column (index)
  (case index
    ({_  c}
     c)))

(defn+ p-advance-index (matched-input index)
  (case index
    ({ln col}
     (case matched-input
       (mi
        (when (or (is_list mi)
                  (is_binary mi)))
        (lists/foldl p-advance-index/2 index
                     (unicode/characters_to_list mi)))
       (\\n
        {(+ ln 1) 1})
       (_
        {ln (+ col 1)})))))

(defn+ p-charclass (class)
  (case class
    (class (when (erlang/is_list class))
           (p-charclass (erlang/list_to_binary class)))
    (class
     (when (erlang/is_binary class))
     (case (re/compile class  [:unicode :dotall])
       ({:ok re}
        (fn (inp index)
            (case (re/run inp re [:anchored])
              ({:match ({0 length} . _)}
               (case (erlang/split_binary inp length)
                 ({head tail}
                  {head tail (p-advance-index head index)})))
              (_
               {:fail {:expected {:character-class
                                  (erlang/binary_to_list class)} index}}))))))))

(defn+ p-anything ()
  (fn (input index)
      (case input
        (<<>>
         {:fail {:expected :any-character index}})
        (<<(c :utf8) (rest :binary)>>
         {c rest (p-advance-index c index)}))))


(defn+ p-string (s)
  (case s
    (s (when (erlang/is_list s))
       (p-string (erlang/list_to_binary s)))
    (s (when (erlang/is_binary s))
       (let (length (erlang/byte_size s))
         (fn (input index)
             (case input
               (<<(s :size length :binary) (rest :binary)>>
                {s rest (p-advance-index s index)})
               (_
                {:fail {:expected {:string s} index}})))))))

(defn+ p-scan (p inp index acc)
  (case inp
    ([]
     {(lists/reverse acc) [] index})
    (_
     (case (p inp index)
       ({:fail _}
        {(lists/reverse acc) inp index})
       ({result inprem new-index}
        (p-scan p inprem new-index (result . acc)))))))

(defn+ p-one-or-more (p)
  (fn (input index)
      (let (result (p-scan p input index []))
        (case result
          ({(_ . _) _ _}
           result)
          (_
           (case (p input index)
             ({:fail {:expected failure e}}
              {:fail {:expected {:at-least-one failure} index}})))))))

(defn+ p-zero-or-more (p)
  (fn (input index)
      (p-scan p input index [])))

(defn+ p-attempt (in-p input index first-failure)
  (case in-p
    ([]
     first-failure)
    ((p . parsers)
     (case (p input index)
       ((= {:fail _} failure)
        (case first-failure
          (:none
           (p-attempt parsers input index failure))
          (_
           (p-attempt parsers input index first-failure))))
       (result
        result)))))

(defn+ p-choose (parsers)
  (fn (input index)
      (p-attempt parsers input index :none)))

(defn+ p-all (in-p input index acc)
  (case in-p
    ([]
     {(lists/reverse acc) input index})
    ((p . parsers)
     (case (p input index)
       ((= {:fail _} failure)
        failure)
       ({result input-rem new-index}
        (p-all parsers input-rem new-index (result . acc)))))))

(defn+ p-seq (p)
  (fn (input index)
      (p-all p input index [])))

(defn+ p-and (p)
  (fn (input index)
      (p-all p input index [])))

(defn+ p-assert (p)
  (fn (input index)
      (case (p input index)
        ((= {:fail _} failure)
         failure)
        (_
         {[] input index}))))

(defn+ p-not (p)
  (fn (input index)
      (case (p input index)
        ({:fail _}
         {[] input index})
        ({result _ _}
         {:fail {:expected {:no-match result} index}}))))

(defn+ p-optional (p)
  (fn (input index)
      (case (p input index)
        ({:fail _}
         {[] input index})
        ((= {_ _ _} success)
         success))))

(defn+ p-eol ()
  (fn (input index)
      ((p-charclass <<"[\n\r]">>) input index)))

(defn+ p-eof ()
  (fn (input index)
      (case input
        (<<>>
         {:eof <<>> index})
        (_
         {:fail {:expected :eof index}}))))

;; ### Memoization Support Functions
;;
;; The following functions support memoization of for the parser. This
;; is critically important to getting any kind of reasonable speed at
;; all out of the parser.
(definline memo-table-name ()
  (erlang/get :parse-memo-table))

(definline get-memo (index name)
  (case (ets/lookup (memo-table-name) index)
    ([]
     {:error :not-found})
    ([{index plist}]
     (case (proplists/lookup name plist)
       ({name result}
        {:ok result})
       (_
        {:error :not-found})))))

(definline memoize (index name result)
  (let (memo (case (ets/lookup (memo-table-name) index)
               ([]
                [])
               ([{index plist}]
                plist)))
    (ets/insert (memo-table-name) {index ({name result} . memo)})))

(defn+ release-memo ()
  (ets/delete (memo-table-name)))

(defn+ setup-memo ()
  (erlang/put :parse-memo-table (ets/new :joxa.compiler [:set])))

(defn+ p (inp start-index name parse-fun transform-fun)
  (case (get-memo start-index name)
    ({:ok memo}
     memo)
    (_
     (let (result (case (parse-fun inp start-index)
                    ((= {:fail _} failure)
                     failure)
                    ({match inp-rem new-index}
                     {(transform-fun match start-index)
                      inp-rem new-index})))
       (memoize start-index name result)
       result))))

(defn+ p (inp start-index name parse-fun)
  (p inp start-index name parse-fun (fn (n idx) n)))

;; ### Joxa Grammer Lexer
;;
;; The following functions represent the grammer of Joxa and can be
;; built on and used by reader macros.
(defn+ space (input index)
  (p input index :space
     (p-charclass <<"[ \t\n\s\r]">>)))

(defn+ comment (input index)
  (p input index :comment
     (p-seq [(p-string <<";">>)
             (p-zero-or-more (p-charclass <<"[^\n\r]">>))
             (p-choose [(p-eol)
                        (p-eof)])])))

(defn+ ignorable (input index)
  (p input index :ignorable
     (p-optional (p-zero-or-more (p-choose [space/2
                                            (p-string <<",">>)
                                            comment/2])))
     (fn (node idx)
         [])))

(defn+ digit (input index)
  (p input index :digit
     (p-charclass <<"[0-9]">>)))

(defn+ int-part (input index)
  (p input index :int-part
     (p-seq [(p-optional (p-string <<"-">>)),
             (p-one-or-more digit/2)])))

(defn+ frac-part (input index)
  (p input index :frac-part
     (p-seq [(p-string <<".">>)
             (p-one-or-more digit/2)])))

(defn+ integer (input index)
  (p input index :integer
     int-part/2
     (fn (node idx)
         (let (result
               (erlang/list_to_integer
                (erlang/binary_to_list
                 (erlang/iolist_to_binary node))))
           {:integer result idx}))))

(defn+ e (input index)
  (p input index :e
     (p-seq [(p-charclass <<"[eE]">>)
             (p-optional (p-choose [(p-string <<"+">>)
                                    (p-string <<"-">>)]))])))

(defn+ exp-part (input index)
  (p input index :exp-part
     (p-seq [e/2
             (p-one-or-more digit/2)])))

(defn+ float (input index)
  (p input index :float
     (p-seq [int-part/2
             frac-part/2
             (p-optional exp-part/2)])
     (fn (node idx)
         (let (result (erlang/list_to_float
                       (erlang/binary_to_list
                        (erlang/iolist_to_binary node))))
           {:float result idx}))))

(defn+ char (input index)
  (p input index :char
     (p-seq [(p-string <<"\\">>)
             (p-choose [(p-string "\\\"")
                        (p-string "\\\\")
                        (p-string "\\b")
                        (p-string "\\f")
                        (p-string "\\n")
                        (p-string "\\r")
                        (p-string "\\t")
                        (p-anything)])])
     (fn (node idx)
         (case node
           ([_ <<"\\\"">>]
            {:char \" idx})
           ([_ <<"\\\\">>]
            {:char \\ idx})
           ([_ <<"\\b">>]
            {:char \\b idx})
           ([_ <<"\\f">>]
            {:char \\f idx})
           ([_ <<"\\n">>]
            {:char \\n idx})
           ([_ <<"\\r">>]
            {:char \\r idx})
           ([_ <<"\\t">>]
            {:char \\t idx})
           ([_ char]
            {:char char idx})))))

(defn+ ident (input index)
  (p input index :ident
     (p-one-or-more
      (p-and [(p-not
               (p-choose [(p-string <<"<<">>)
                          (p-string <<">>">>)
                          (p-charclass <<"[,'\\\\{}/\t\n\s\r\\(\\)\\[\\]\"]">>)]))
              (p-anything)]))
     (fn (node idx)
         (let (result
               (erlang/list_to_atom
                (erlang/binary_to_list
                 (erlang/iolist_to_binary node))))
           {:ident result idx}))))

(defn+ symbol (input index)
  (p input index :symbol
     (p-seq [(p-string ":")
             ignorable/2
             (p-one-or-more
              (p-and [(p-not (p-charclass <<"[,\\\\{}\t\n\s\r\\(\\)\\[\\]\"]">>))
                      (p-anything)]))])
     (fn (node idx)
         (case node
           ([_ _ value]
            (let (result (erlang/list_to_atom
                          (erlang/binary_to_list
                           (erlang/iolist_to_binary value))))
              {:quote {:ident result idx} idx}))))))

(defn+ fun-reference (input index)
  (p input index :fun-reference
     (p-choose [(p-seq [ident/2
                        (p-string "/")
                        ident/2
                        (p-string "/")
                        integer/2])
                (p-seq [ident/2
                        (p-string "/")
                        integer/2])
                (p-seq [ident/2
                        (p-string "/")
                        ident/2])])
     (fn (node idx)
         (case node
           ([{:ident module _} _
             {:ident function _} _
             {:integer arity _}]
            {:call {:--fun module function arity} idx})
           ([{:ident function _} _
             {:integer arity _}]
            {:call {:--fun function arity} idx})
           ([{:ident module _} _
             {:ident function _}]
            {:call {:--fun module function} idx})))))

(defn+ string (input index)
  (p input index :string
     (p-seq [(p-string "\"")
             (p-zero-or-more (p-seq [(p-not (p-string "\""))
                                     (p-choose [(p-string "\\\"")
                                                (p-string "\\\\")
                                                (p-string "\\b")
                                                (p-string "\\f")
                                                (p-string "\\n")
                                                (p-string "\\r")
                                                (p-string "\\t")
                                                (p-anything)])]))
             (p-string "\"")])

     (fn (node idx)
         (case node
           ([_ string _]
            (let (convert (lists/map (fn (el)
                                         (case el
                                           ([_ <<"\\\"">>]
                                            <<"\"">>)
                                           ([_ <<"\\\\">>]
                                            <<"\\">>)
                                           ([_ <<"\\b">>]
                                            <<"\b">>)
                                           ([_ <<"\\f">>]
                                            <<"\f">>)
                                           ([_ <<"\\n">>]
                                            <<"\n">>)
                                           ([_ <<"\\r">>]
                                            <<"\r">>)
                                           ([_ <<"\\t">>]
                                            <<"\t">>)
                                           (_
                                            el)))
                                     string)
                          result (erlang/binary_to_list (erlang/iolist_to_binary convert)))
              {:string result idx}))))))

;; A forward declaration to support the mutually recursive types
;; in the parser
(deftype+ index () {(erlang/non_neg_integer) (erlang/non_neg_integer)})
(defspec value ((binary) (index)) {:fail (erlang/any)})

(defn+ quote (input index)
  (p input index :quote
     (p-seq [(p-string "'")
             value/2])
     (fn (node idx)
         (case node
           ([_ item]
            {:quote item idx})))))

(defn+ list (input index)
  (p input index :list
     (p-choose [(p-seq [(p-string "(")
                        ignorable/2
                        value/2
                        (p-zero-or-more (p-seq [ignorable/2
                                                value/2]))
                        ignorable/2
                        (p-string ")")])
                (p-seq [(p-string "(")
                        ignorable/2
                        (p-string ")")])
                (p-seq [(p-string "[")
                        ignorable/2
                        value/2
                        (p-zero-or-more (p-seq [ignorable/2
                                                value/2]))
                        ignorable/2
                        (p-string "]")])
                (p-seq [(p-string "[")
                        ignorable/2
                        (p-string "]")])])
     (fn (node idx)
         (case node
           ([<<"(">> _ h t _ _]
            {:list (lists/flatten [h t]) idx})
           ([<<"[">> _ h t _ _]
            {:literal-list (lists/flatten [h t]) idx})
           ([<<"[">> _ _]
            {:literal-list [] idx})
           ([_ _ _]
            {:list [] idx})))))

(defn+ tuple (input index)
  (p input index :tuple
     (p-choose [(p-seq [(p-string "{")
                        ignorable/2
                        value/2
                        (p-zero-or-more (p-seq [ignorable/2
                                                value/2]))
                        ignorable/2
                        (p-string "}")])
                (p-seq [(p-string "{")
                        ignorable/2
                        (p-string "}")])])
     (fn (node idx)
         (case node
           ([_ _ h t _ _]
            {:tuple (lists/flatten [h t]) idx})
           ([_ _ _]
            {:tuple [] idx})))))

(defn+ binary (input index)
  (let (binary-contents (p-choose [integer/2
                                   char/2
                                   ident/2
                                   list/2]))
    (p input index :binary
       (p-choose [(p-seq [(p-string "<<")
                          ignorable/2
                          binary-contents
                          (p-zero-or-more (p-seq [ignorable/2
                                                  binary-contents]))
                          ignorable/2
                          (p-string ">>")])
                  (p-seq [(p-string "<<")
                          ignorable/2
                          string/2
                          ignorable/2
                          (p-string ">>")])
                  (p-seq [(p-string "<<")
                          ignorable/2
                          (p-string ">>")])])
       (fn (node idx)
           (case node
             ([_ _ h t _ _]
              {:binary (lists/flatten [h t]) idx})
             ([_ _ string _ _]
              {:binary string idx})
             ([_ _ _]
              {:binary [] idx}))))))

(defn+ value (input index)
  (p input index :value
     (p-seq [ignorable/2
             (p-choose [float/2
                        integer/2
                        binary/2
                        symbol/2
                        fun-reference/2
                        ident/2
                        list/2
                        tuple/2
                        string/2
                        quote/2
                        char/2])
             ignorable/2])
     (fn (node idx)
         (lists/nth 2 node))))

;; ### Path Hashing for Line and Type Information
;;
;; We have the problem that for macros and for ease of parsing we want
;; to keep the AST as clean as possible. That is, we want it to be as
;; close to a normal list as we can get away with. However, we want to
;; be able to hang information on the graph that the AST
;; represents. Things like line numbers, additional type information
;; etc. However, in erlang we cant do that without polluting the graph
;; itself and making it harder for user written macros to be
;; implemented. So we need some way to identify specific points in the
;; graph that is the AST that we can then use as a key on this
;; additional information that we would like to show.
;;
;; In an AST nodes are identified by their location in the graph. That
;; is, every node in the graph is identified by the path leading to
;; that node.  Lets look at an example.
;;
;;     (hello world (I rock))
;;
;; In this case the 'I' node could be identified by the path [hello,
;; world, <start of children>, I]. This should be a unique identifier
;; for any point in the graph assuming that there is a single root
;; term being parsed.
;;
;; If that is true we can replace the actual elements with their
;; positions in the list. So the example above would become. [1, 3,
;; 1]. Where the outer list is 1 (everything starts at one) the 3rd
;; position is the list and the first element in that third
;; position. Lets look at something a bit more something more realistic.
;;
;;     (defn+ hello-world [foo bar] (baz bang bong))
;;
;; In this example the bang node could be identified by everything
;; leading up to it. So the path would be [defn+, hello-world,
;; <children>, <start-of_children>, bang]. Lets translate this to our
;; simple numerical paths. [1, 4, 2]. This should work to any level in
;; the graph.
;;
;; We can make it even easier to manipulate buy having the firstest
;; point in the graph be the closest point in the list so that we can
;; push onto the list as we go forward. The actual path in the example
;; above would be [2, 4, 1] and built up each time we see a list.
(deftype path () {(erlang/non_neg_integer) [(erlang/non_neg_integer)]})

(defn+ new-path ()
  {1, []})

(defn+ incr-path (pos path)
  (case path
    ({oldpos oldpath}
     {(+ pos oldpos) oldpath})))

(defn+ incr-path (path)
  (incr-path 1 path))

(defn+ traverse-path (path)
  (case path
    ({old-position old-path}
     {1, (old-position . old-path)})))

(defn+ path? (path)
  (case path
    ({_ old-path}
     old-path)))

(defn+ traverse-and-get-path (path)
  (path? (traverse-path path)))

(defn+ traverse-incr-path (path)
  (traverse-path (incr-path path)))

(defn+ traverse-incr-path (amount path)
  (traverse-path (incr-path amount path)))


;; ### Annotation storage and retrieval
;;
;; With path support in place its time take care of the annotations
;; themselves. We want the api to handle formating and internal
;; storage forms. As long as we give it a good path we want to get
;; back what we ask for.
(defn+ new-annots (file-name)
  (ec_dictionary/add :__filename__ file-name (ec_dictionary/new :ec_dict)))

(defn+ add-annots (path type idx annotations)
  (let (file-name (ec_dictionary/get :__filename__ annotations))
    (case idx
      ({line _}
       (ec_dictionary/add path {type idx [line, {:file file-name}]}
                          annotations)))))

;; sometimes an invalid path is passed in. This is unfortunate but
;; things like macros mangle the path in currently unforseable
;; ways. With this in mind we keep backing up the path until such time
;; that we get a valid annotation. This lets us give at least the line
;; number and annotations of the top most related form.
(defn get-valid-annots (path annotations)
  (case path
    ([]
     (erlang/throw :not-found))
    ((_ . rest)
     (__try
      (ec_dictionary/get path annotations)
      (catch (type body)
        (case {type body}
          ({:throw :not_found}
           (get-valid-annots rest annotations))))))))

(defn+ get-type-annots (path annotations)
  (case (get-valid-annots path annotations)
    ({type _ _}
     type)))

(defn+ get-idx-annots (path annotations)
  (case (get-valid-annots path annotations)
    ({_ idx _}
     idx)))

(defn+ get-line-annots (path annotations)
  (case (get-valid-annots path annotations)
    ({_ _ line}
     line)))

(defn+ get-line-annots (path extra annotations)
  (let (annots (get-line-annots path annotations))
    (extra . annots)))

;; ### The First Ast Transformation
;;
;; Most of the AST transformations in Joxa happen via macros. however,
;; this very first initial transformation happens here. Turning the
;; marked up AST into an annotated lisp AST where the annotations are
;; hidden unless requested.

(defspec transform-ast ((erlang/any) (erlang/any) (erlang/any))
  {(erlang/any) (erlang/list)})

(definline convert-list-ast (path0 annotations0 elements idx)
  (let (transformed
        (lists/foldl
         (fn (el, acc)
             (case acc
               ({path1 annotations1 elements-acc}
                (let (result (transform-ast
                              (traverse-path path1)
                              annotations1 el))
                  (case result
                    ({annotations2 transformed}
                     {(incr-path path1) annotations2
                      (transformed . elements-acc)}))))))
         {path0 annotations0 []}
         elements))
    transformed))

(definline convert-list-call-ast (path0 annotations0 elements idx type)
  (let (transformed
        (convert-list-ast (incr-path path0)
                          annotations0 elements idx))
    (case transformed
      ({_ annotations3 transform-list}
       (let (annotations4 (add-annots (traverse-and-get-path path0)
                                      :ident
                                      idx annotations3))
         {(add-annots (path? path0)
                      type idx
                      annotations4)
          (type . (lists/reverse transform-list))})))))

(definline convert-binary-string (path0 annotations0 elements idx)
  (let (transformed
        (lists/foldl
         (fn (el, acc)
             (case acc
               ({path1 annotations1 elements-acc}
                {(incr-path path1)
                 (add-annots (traverse-and-get-path path1)
                             :integer
                             idx
                             annotations1)
                 (el . elements-acc)})))
         {path0 annotations0 []}
         elements))
    (case transformed
      ({_ annotations3 transform-list}
       (let (annotations4 (add-annots
                           (traverse-and-get-path path0)
                           :ident
                           idx annotations3))
         {(add-annots (path? path0)
                      :binary idx
                      annotations4)
          (:binary . (lists/reverse transform-list))})))))

(defn+ transform-ast (path0 annotations node)
  (case node
    (:fail
     (erlang/throw :fail))
    ({:call mfa idx}
     {(add-annots (path? path0)
                  :call idx annotations) mfa})
    ({:literal-list list idx}
     (convert-list-call-ast path0 annotations list idx :list))
    ({:binary {:string string _} idx}
     (convert-binary-string path0 annotations string idx))
    ({:binary list idx}
     (convert-list-call-ast path0 annotations list idx :binary))
    ({:tuple list idx}
     (let (transformed (convert-list-ast path0 annotations list idx))
       (case transformed
         ({_ annotations1 transform-list}
          {(add-annots (path? path0)
                       :tuple idx
                       annotations1)
           (erlang/list_to_tuple (lists/reverse transform-list))}))))
    ({:list list idx}
     (let (transformed (convert-list-ast path0 annotations list idx))
       (case transformed
         ({_ annotations1 transform-list}
          {(add-annots (path? path0)
                       :list idx
                       annotations1)
           (lists/reverse transform-list)}))))
    ({:string result idx}
     {(add-annots (path? path0) :string idx
                  (add-annots (traverse-and-get-path path0)
                              :ident idx
                              annotations))
      [:string, result]})
    ({type (= val {_ _ _}) idx}
     (let (result (transform-ast (traverse-incr-path path0)
                                 annotations val))
       (case result
         ({annotations1 p-val}

          {(add-annots (path? path0) type idx
                       (add-annots (traverse-and-get-path path0)
                                   :ident idx
                                   annotations1))
           [type, p-val]}))))
    ({type val idx}
     {(add-annots (path? path0) type idx annotations) val})))

;; These are mostly exponsed for testing purposes
(defn+ intermediate-parse (input index)
  (setup-memo)
  (let (result (value input index))
    (release-memo)
    result))

(defn+ intermediate-parse (input)
  (intermediate-parse input {1,1}))

(defn+ new-index ()
  {1,1})

(defn+ has-more-data-to-parse (input)
  (case input
    (<<>>
     :false)
    ({:parse-output <<>> _ _ _}
     :false)
    (_
     :true)))

(defn do-parse (path annots input idx0)
  (case input
    (<<>>
     {<<>> path annots idx0})
    (_
     (case (intermediate-parse input idx0)
       ({:fail {:expected expected idx1}}
        (erlang/throw {:invalid-form expected idx0}))
       ({intermediate-ast rest idx2}
        (case (transform-ast (traverse-path path) annots
                             intermediate-ast)
          ({annots1 final-ast}
           {annots1 final-ast {:parse-output rest path annots1 idx2}})))))))

(defn+ parse (file-name input)
  (case input
    (input (when (erlang/is_binary input))
           (do-parse (new-path)
                     (new-annots file-name)
                     input
                     (new-index)))
    ({:parse-output new-input path annots index}
     (do-parse (incr-path path) annots new-input index))))

(defn+ parse-file (filename)
  (case (file/read_file filename)
    ({:ok bin}
     (parse filename bin))))

;; The Compiler
;; ------------
;;
;; The parser is complete and now its time to turn our attention to
;; the compiler. we start by defining a compilation context to use for
;; scope management and variable lookup.


;; ### The Context

(deftype context ()
  {:context,
   (erlang/atom)
   (erlang/list)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)
   (erlang/term)})

;; ### Specifications for broadly used compilation functions
(defspec make-literal ((path) (context) (erlang/term)) (cerl/cerl))

;; ### Context Implementation
(defn+ get-context (field ctx)
  (case field
    (:module-name (erlang/element 2 ctx))
    (:annots (erlang/element 3 ctx))
    (:attrs (erlang/element 4 ctx))
    (:exports (erlang/element 5 ctx))
    (:type-exports (erlang/element 6 ctx))
    (:scopes (erlang/element 7 ctx))
    (:type-scopes (erlang/element 8 ctx))
    (:definitions (erlang/element 9 ctx))
    (:types (erlang/element 10 ctx))
    (:aliases (erlang/element 11 ctx))
    (:requires (erlang/element 12 ctx))
    (:uses (erlang/element 13 ctx))
    (:line (erlang/element 14 ctx))
    (:options (erlang/element 15 ctx))
    (:rests (erlang/element 16 ctx))
    (:anon-fun-index (erlang/element 17 ctx))
    (:fun-deps (erlang/element 18 ctx))
    (_ (erlang/throw {:invalid-field, :context field}))))

(defn+ set-context (field value ctx)
  (case field
    (:module-name (erlang/setelement 2 ctx value))
    (:annots (erlang/setelement 3 ctx value))
    (:attrs (erlang/setelement 4 ctx value))
    (:exports (erlang/setelement 5 ctx value))
    (:type-exports (erlang/setelement 6 ctx value))
    (:scopes (erlang/setelement 7 ctx value))
    (:type-scopes (erlang/setelement 8 ctx value))
    (:definitions (erlang/setelement 9 ctx value))
    (:types (erlang/setelement 10 ctx value))
    (:aliases (erlang/setelement 11 ctx value))
    (:requires (erlang/setelement 12 ctx value))
    (:uses (erlang/setelement 13 ctx value))
    (:line (erlang/setelement 14 ctx value))
    (:options (erlang/setelement 15 ctx value))
    (:rests (erlang/setelement 16 ctx value))
    (:anon-fun-index (erlang/setelement 17 ctx value))
    (:fun-deps (erlang/setelement 18 ctx value))
    (_ (erlang/throw {:invalid-field, :context field}))))

(defn+ new-context (key-values)
  (lists/foldl (fn (set-val ctx1)
                   (case set-val
                     ({field value}
                      (set-context field value ctx1))))
               {:context
                :undefined ; module-name
                :undefined ; annots
                []  ; attrs
                (sets/new) ; exports
                (sets/new) ; type-exports
                [] ; scopes
                [] ; type-scopes
                [] ; definitions
                (ec_dictionary/new :ec_dict) ; types
                (ec_dictionary/new :ec_dict) ; alias
                (ec_dictionary/new :ec_dict) ; require
                (ec_dictionary/new :ec_dict) ; use
                :undefined ; line
                [] ; context
                [] ; rest functions
                -1 ; anonymous function index
                (sets/new) ; fun deps
                } key-values))

(defn+ new-context (annots module-name)
  (new-context ([(:annots . annots)
                 (:module-name . module-name)])))

(defn incr-fun-index-ctx (ctx)
  (set-context :anon-fun-index (erlang/+ (get-context :anon-fun-index ctx) 1) ctx))

(defn+ add-export-ctx (annots fun-name arity ctx)
  (let (exports (get-context :exports ctx))
    (set-context
     :exports (sets/add_element {fun-name arity annots} exports)
     ctx)))

(defn add-rest-ctx (name arity ctx)
  (let (rests (get-context :rests ctx))
    (case (lists/any (fn (el)
                         (erlang/== el name)) rests)
      (:true
       (erlang/throw {:rest-fun-exists name}))
      (:false
       (set-context :rests ({name arity}  . rests) ctx)))))

(defn+ add-attr-ctx (key value ctx)
  (let (attrs (get-context :attrs ctx))
    (set-context :attrs ({key value} . attrs) ctx)))

(defn+ add-alias-ctx (aliased-name module ctx)
  (let (aliases (get-context :aliases ctx))
    (set-context :aliases
                 (ec_dictionary/add aliased-name module aliases)
                 ctx)))

(defn+ add-require-ctx (module ctx)
  (let (requires (get-context :requires ctx)
        exports ((erlang/make_fun module :module_info 1) :exports))
    (set-context :requires (ec_dictionary/add module exports requires)
                 ctx)))

(defn+ add-use-ctx (alias arity target module ctx)
  (let (use (get-context :uses ctx))
    (set-context :uses (ec_dictionary/add {alias arity}
                                          {target module} use)
                 ctx)))

(defn+ add-def-ctx (annots name vars body ctx replace)
  (let (arity (erlang/length vars)
        defs (get-context :definitions ctx)
        fun-deps (get-context :fun-deps ctx)
        cerl-name (cerl/ann_c_fname annots name arity)
        cerl-body (cerl/ann_c_fun annots vars body))

    (case replace
      (:replace
       (case (lists/keymember {name arity} 1 defs)
         (:true
          (set-context :definitions
                       (lists/keyreplace {name arity} 1
                                         defs
                                         {{name arity} {cerl-name cerl-body fun-deps}})
                       ctx))
         (:false
          (set-context :definitions
                       (lists/append defs
                                     [{{name arity} {cerl-name cerl-body fun-deps}}])
                       ctx))))
      (_
       (lists/foreach (fn (el)
                          (case el
                            ({{name arity}, _}
                             (erlang/throw {:function-exists name arity}))
                            (_
                             :ok))) defs)
       (set-context :fun-deps (sets/new)
                    (set-context :definitions
                                 (lists/append defs [{{name arity} {cerl-name cerl-body fun-deps}}])
                                 ctx))))))

(defn+ add-def-ctx (annots name vars body ctx)
  (add-def-ctx annots name vars body ctx :no-replace))

(defn+ add-exported-def-ctx (annots name vars body ctx replace)
  (let (arity (erlang/length vars))
    (add-export-ctx annots name arity
                    (add-def-ctx annots name vars body ctx replace))))

(defn+ add-exported-def-ctx (annots name vars body ctx)
  (add-exported-def-ctx annots name vars body ctx :no-replace))

(defn add-fun-dep-ctx (name arity ctx)
  (let (fun-deps (get-context :fun-deps ctx))
    (set-context :fun-deps (sets/add_element {name arity} fun-deps) ctx)))

(defspec alias-ctx? ((erlang/atom) (erlang/atom)
                     (erlang/non_neg_integer) (erlang/term))
  (erlang/term))

(defn get-joxa-info (type module fun-name)
  (__try
   (let (info-fun (erlang/make_fun module :--joxa-info 2))
     (info-fun type fun-name))
   (catch (type body)
     (case {type body}
       ({:error :undef}
        :false)
       (_
        (erlang/raise type body (erlang/get_stacktrace)))))))

(defn+ rest-remote-reference-ctx? (module function possible-arity exports)
  (case (get-joxa-info :rest module function)
    (:false
     :not-a-reference)
    (arity (when (erlang/is_integer arity))
           {:remote-rest {module function arity}})))

(defn+ remote-function-ctx? (module function possible-arity ctx aliased)
  (__try
   (let (requires (get-context :requires ctx)
         exports (ec_dictionary/get module requires))
     (case (rest-remote-reference-ctx? module function possible-arity exports)
       (:not-a-reference
        (case (lists/member {function possible-arity} exports)
          (:true
           {:remote {module function possible-arity}})
          (:false
           :not-a-reference)))
       (return-val
        return-val)))
   (catch (_type body)
     (case body
       (:not_found
        (case aliased
          (:false
           (alias-ctx? module function possible-arity ctx))
          (:true
           :not-a-reference)))))))

(defn+ remote-function-ctx? (module function possible-arity ctx)
  (remote-function-ctx? module function possible-arity ctx :false))

(defn+ alias-ctx? (module function possible-arity ctx)
  (__try
   (let (aliases (get-context :aliases ctx)
         aliased-module  (ec_dictionary/get module aliases))
     (remote-function-ctx?
      aliased-module function possible-arity ctx :true))
   (catch (type body)
     (case body
       (:not_found
        :not-a-reference)))))

(defn is-local-rest-fun (name possible-arity ctx)
  (let (rests (get-context :rests ctx))
    (lists/foldl (fn (el acc)
                     (case acc
                       (:false
                        (case el
                          ({name arity} (when (erlang/>= possible-arity arity))
                           {:true arity})
                          (_
                           :false)))
                       (_
                        acc))) :false rests)))

(defn is-speced-ctx? (name possible-arity ctx)
  (let (types (get-context :types ctx))
    (case (ec_dictionary/get {name possible-arity} :undefined types)
      (:undefined
       :not-a-reference)
      (_
       {:apply {name possible-arity}}))))

(defn rest-used-function? (name uses)
  (lists/foldl (fn (el acc)
                   (case acc
                     (:not-a-reference
                      (case el
                        ({{name _} {real-fun module}}
                         (case (get-joxa-info :rest module real-fun)
                           (:false
                            :not-a-reference)
                           (arity (when (erlang/is_integer arity))
                                  {:remote-rest {module real-fun arity}})))
                        (_
                         :not-a-reference)))
                     (_
                      acc))) :not-a-reference (ec_dictionary/to_list  uses)))

(defn used-function-ctx? (name possible-arity ctx)
  (let (uses (get-context :uses ctx))
    (case (rest-used-function? name uses)
      (:not-a-reference
       (case (ec_dictionary/get {name possible-arity} :undefined uses)
         ({fun-name module-name}
          {:remote {module-name fun-name possible-arity}})
         (:undefined
          (is-speced-ctx? name possible-arity ctx))))
      (result
       result))))

(defn+ rest-defined-function-ctx? (function possible-arity ctx)
  (case (is-local-rest-fun function possible-arity ctx)
    ({:true arity}
     {:apply-rest {function arity}})
    (_
     :not-a-reference)))

(defn+ defined-used-function-ctx? (name possible-arity ctx)
  (case (rest-defined-function-ctx? name possible-arity ctx)
    (:not-a-reference
     (let (defs (get-context :definitions ctx))
       (case (lists/any (fn (el)
                            (case el
                              ({{name possible-arity} _}
                               :true)
                              (_
                               :false)))
                        defs)
         (:true
          {:apply {name possible-arity}})
         (:false
          (used-function-ctx? name possible-arity ctx)))))
    (rest-apply
     rest-apply)))

(defn+ push-scope-ctx (ctx)
  (let (scopes (get-context :scopes ctx))
    (set-context :scopes ((ec_dictionary/new :ec_dict) . scopes) ctx)))

(defn+ pop-scope-ctx (ctx)
  (case (get-context :scopes ctx)
    ((_ . scopes)
     (set-context :scopes scopes ctx))))

(defspec idx-from-context ([(erlang/atom)] (path) (context)) {(erlang/non_neg_integer)
                                                              (erlang/non_neg_integer)})

(defn+ add-reference-to-scope-ctx (name arity cerl-var path0 ctx0 )
  (let (scopes (get-context :scopes ctx0))
    (case scopes
      ((current . rest)
       (case (ec_dictionary/get name :not-in-scope current)
         (:not-in-scope
          (set-context :scopes
                       ((ec_dictionary/add name {cerl-var arity} current) . rest) ctx0))
         (_
          (erlang/throw {:variable-redefinition name
                                                (idx-from-context [] path0 ctx0)}))))
      ([]
       (erlang/throw :no-scope)))))

(defn+ resolve-reference-ctx (ref arity ctx)
  (case ref
    ({:--fun _ arity}
     (when (erlang/is_integer arity))
     (defined-used-function-ctx? ref arity ctx))
    ({:--fun module function}
     (when (and (erlang/is_atom module)
                (erlang/is_atom function)))
     (remote-function-ctx? module function arity ctx))
    ({:--fun fun invalid-arity}
     (erlang/throw {:mismatched-arity fun arity invalid-arity}))
    ({:--fun module function arity}
     (remote-function-ctx? module function arity ctx))
    ({:--fun module function invalid-arity}
     (erlang/throw {:mismatched-arity module function arity invalid-arity}))
    (name
     (when (erlang/is_atom name))
     (let (scopes (get-context :scopes ctx))
       (case (ec_lists/search (fn (scope)
                                  (__try
                                   {:ok (ec_dictionary/get name scope)}
                                   (catch (_type body)
                                     (case body
                                       (:not_found
                                        :not_found))))) scopes)
         ({:ok {var new-arity}  _} (when (erlang/or (erlang/== -1 arity)
                                                    (erlang/== new-arity arity)))
          {:reference {var new-arity}})
         (_
          (defined-used-function-ctx? name arity ctx)))))
    (_
     :not-a-reference)))

(defn push-type-scope-ctx (ctx0)
  (let (type-scopes (get-context :type-scopes ctx0))
    (set-context :type-scopes ((sets/new) . type-scopes) ctx0)))

(defn pop-type-scope-ctx (ctx0)
  (case (get-context :type-scopes ctx0)
    ((_ . scopes)
     (set-context :type-scopes scopes ctx0))))

(defn add-type-reference-to-scope-ctx (name arity ctx0)
  (case (get-context :type-scopes ctx0)
    ((current . scopes)
     (set-context :type-scopes ((sets/add_element {name arity} current) . scopes) ctx0))))

(defn resolve-type-reference-ctx (name arity ctx)
  (let (type-scopes (get-context :type-scopes ctx)
        types (get-context :types ctx))
    (case (lists/any (fn (set-scope)
                         (sets/is_element {name arity} set-scope)) type-scopes)
      (:true
       :true)
      (:false
       (case (ec_dictionary/get {name arity} :undefined types)
         (:undefined
          :false)
         (_
          :true))))))

(defn add-type-export-ctx (type-name arity ctx0)
  (let (type-exports (get-context :type-exports ctx0))
    (set-context :type-exports (sets/add_element {type-name arity} type-exports) ctx0)))

(defn add-type-ctx (type-name arity body ctx0)
  (let (types (get-context :types ctx0))
    (set-context :types  (ec_dictionary/add {type-name arity}  body types) ctx0)))

;; #### Context Helper Functions
;;
;; These mostly exist to reduce the visual cost of function calls to
;; get values from the annotations.
(defn thing-from-context (actions path0 ctx do-fun)
  (let (do-action (fn (action path1)
                      (case action
                        (:traverse
                         (traverse-path path1))
                        (:incr
                         (incr-path path1))))
        path1     (case actions
                    (a1 (when (erlang/is_list a1))
                        (lists/foldl do-action/2 path0 actions))
                    (a2 (when (erlang/is_atom a2))
                        (do-action actions path0))))
    (do-fun (path? path1) (get-context :annots ctx))))

(defn idx-from-context (actions path0 ctx)
  (thing-from-context actions path0 ctx get-idx-annots/2))

(defn annots-from-context (actions path0 ctx)
  (thing-from-context actions path0 ctx get-line-annots/2))


;; Module Compilation
;; ------------------
;;
;; The form of the module is defined as follows.
;;
;;     (module <module_name>
;;        <require>
;;        <use>
;;        <attributes>)
;;
;; The module clause is a special form and its contents are not evaluated.
;;
;; comp compiles the provided AST into a Joxa context. Later that context
;; must be compiled to core erlang.
(defn get-exports (module idx)
  (let (mod-info (erlang/make_fun module :module_info 1)
        exports (mod-info :exports))
    (lists/map (fn (el)
                   (case el
                     ({fun arity}
                      {{fun arity} fun})))
               exports)))

(defn gather-fun-arity-pairs (idx fun-arity-list acc)
  (case fun-arity-list
    (({:--fun fun arity} . rest)
     (gather-fun-arity-pairs idx rest ({fun arity} . acc)))
    ([] acc)
    (_
     (erlang/throw {:invalid-use :invalid-fun-spec idx}))))

(defn gather-fun-alias-pairs (idx fun-alias-pairs acc)
  (case fun-alias-pairs
    (([{:--fun fun arity} alias] . rest)
     (when (erlang/is_atom alias))
     (gather-fun-alias-pairs idx rest ({{fun arity} alias} . acc)))
    ([]
     acc)
    (_
     (erlang/throw {:invalid_use :invalid_fun_spec idx}))))

(defn populate-use-into-context (module-name imports ctx0)
  (case imports
    ([] ctx0)
    (_
     (lists/foldl (fn (el ctx1)
                      (case el
                        ({{fun-name arity} alias-name}
                         (add-use-ctx alias-name arity fun-name module-name ctx1))))
                  ctx0
                  imports))))

;; Joxa Module Definitions
;; -----------------------
;;
;; Module declarations in Joxa are more complex then module definitions in
;; Erlang. They follow the Clojure model much more closely then the Erlang
;; module. That is that all modules used in the system must be required. You
;; may provide an alias for a dependent module name in both the require
;; clause and the use clauses. You may also import functions from modules in
;; the use clause.
;;
;; ### Module Form
;; The form of the module is defined as follows.
;;
;;     (module <module_name>
;;        <require>
;;        <use>
;;        <attributes>)
;;
;; The module clause is a special form and its contents are not evaluated.
;;
;; comp compiles the provided AST into a Joxa context. Later that context
;; must be compiled to core erlang.
(defn filter-imports-to-onlys (idx target-funs imports0)
  (let (fun-arity-pairs (gather-fun-arity-pairs idx target-funs '()))
    (lists/foldl (fn (el acc)
                     (case el
                       ({fun arity}
                        (let (new-el {{fun arity} fun})
                          (case (lists/member new-el imports0)
                            (:true
                             (new-el . acc))
                            (:false
                             (erlang/throw {:invalid-use :non-existant-fun-name {fun arity} idx})))))))
                 [] fun-arity-pairs)))

(defn exclude-specific-funs (idx excluded-funs imports0)
  (let (fun-arity-pairs (gather-fun-arity-pairs idx excluded-funs []))
    (lists/foldl (fn (el acc)
                     (case el
                       ({{fun arity} _}
                        (let (new-el {{fun arity} fun})
                          (case (lists/member {fun arity} fun-arity-pairs)
                            (:true
                             acc)
                            (:false
                             (new-el . acc)))))))
                 [] imports0)))

(defn rename-funs (idx renames imports0)
  (let (fun-alias-pairs (gather-fun-alias-pairs idx renames []))
    (lists/foldl (fn (el exports1)
                     (case el
                       ({{fun arity} alias}
                        (lists/keyreplace {fun arity} 1 exports1
                                          {{fun arity} alias}))))
                 imports0 fun-alias-pairs)))

(defspec comp-use ((index) (context) (erlang/term) (erlang/atom) (erlang/list))
  (context))

(defn handle-use-clauses (idx ctx0 forms module-name imports0)
  (case forms
    ([]
     (populate-use-into-context module-name imports0 ctx0))
    (('(quote as) . (alias-name . rest))
     (let (ctx1 (add-alias-ctx alias-name module-name ctx0))
       (handle-use-clauses idx ctx1 rest module-name imports0)))
    (('(quote only) . (target-funs . rest))
     (when (and (erlang/is_atom module-name)
                (erlang/is_list target-funs)))
     (let (imports1 (filter-imports-to-onlys idx target-funs imports0))
       (handle-use-clauses idx ctx0 rest module-name imports1)))
    (('(quote exclude) . (target-funs . rest))
     (when (and (erlang/is_atom module-name)
                (erlang/is_list target-funs)))
     (let (imports1 (exclude-specific-funs idx target-funs imports0))
       (handle-use-clauses idx ctx0 rest module-name imports1)))
    (('(quote rename) . (target-funs . rest))
     (when (and (erlang/is_atom module-name)
                (erlang/is_list target-funs)))
     (let (imports1 (rename-funs idx target-funs imports0))
       (handle-use-clauses idx ctx0 rest module-name imports1)))
    (probably-more-uses
     (comp-use idx ctx0 probably-more-uses module-name imports0))))

(defn module-exists? (mod-name)
  (case (code/ensure_loaded mod-name)
    ({:module _}
     :true)
    ({:error :embedded}
     :true)
    ({:error :native_code}
     :true)
    (_
     :false)))

;; Use Clauses
;; -----------
;;
;; At last we get to the use clauses. Use clauses are, by far, the most
;; complex of the header clauses as the both manipulate and subset the
;; functions buing used while at the same time aliasing the function if
;; required.
;;
;;     (use string)
;;     (use [string :only [tokens/2]])
;;     (use [string :exclude [substr/3 join/2 join/3]])
;;     (use [string :rename ([substr/3 str-substring] [join/2 str-join])])
;;     (use [string :as str :only [join/2 substr/3]])
;;     (use [string :as str :only [tokens/2]])
;;     (use [string :as str :exclude [substr/3 join/2 join/3]])
;;     (use [string :as str :rename ([substr/3 str-substring] [join/2 str-join])])
;;
;; As you can see each clause may consist of a module name, or a vector/list
;; that contains a few some clauses.  The subcluase is always headed by a
;; module name, followed by an action, followed by the subject of that
;; action. The subclause action/subject may ocurre in any order. Even though
;; some do not make sense when used together. So, for example you could have
;; the following
;;
;;     (use [string :rename ([substr/3 str-substring] [join/2 str-join]
;;                  :exclude [substr/4 join/2]
;;                  :as str)])
;;
;; This would be perfectly valid and could use occur in any order at all.

(defn+ comp-use (idx ctx0 form module-name imports)
  (case form
    ([]
     (populate-use-into-context module-name imports ctx0))
    (((use-module-name . clause-body) . rest)
     (when (erlang/is_atom use-module-name))
     (case (module-exists? use-module-name)
       (:true
        (let (ctx1 (add-require-ctx use-module-name ctx0)
              imports (get-exports use-module-name idx)
              ctx2 (handle-use-clauses idx ctx1
                                       clause-body use-module-name imports))
          (comp-use idx ctx2 rest :undefined '())))
       (:false
        (erlang/throw {:invalid-use-clause {:bad-module use-module-name} idx}))))
    ((use-module-name . rest)
     (when (erlang/is_atom use-module-name))
     (let (imports (get-exports use-module-name idx))
       (comp-use idx (populate-use-into-context
                      use-module-name imports ctx0) rest :undefined '())))))


;; Attribute Clauses
;; -----------------
;;
;; Attribute clauses are the simplest of the three clauses There are simply
;; a three element list where the first element is the ident 'attr', the
;; second element is a Joxa term that provides the key value and the third
;; is a Joxa term that provides the value.
;;
;; Attributes follow the form:
;;
;;     (attr <key> <value>)
;;
(defn+ comp-attr (path0 ctx0 form)
  (case form
    ([key value]
     (add-attr-ctx
      (make-literal (traverse-path path0) ctx0 key)
      (make-literal (traverse-incr-path path0) ctx0 value)
      ctx0))
    (_
     (let (idx (idx-from-context :traverse path0 ctx0))
       (erlang/throw {:invalid-attr-clause idx})))))

;; ### Require Clause
;;
;; The require clause is a list that starts with the ident 'require' and
;; then contains a require body. Examples of the require and require bodies
;; appear below.
;;
;;     (require (erlang string test))
;;     (require string [test :as test])
;;     (require [string :as str])
;;     (require [string :as str1])
;;     (require string test)
;;
;; The body of the require contains a list of require clauses, in the form
;;
;;    (erlang string test)
;;    (string [test :as test])
;;
;;  or a simple group of require clauses in the form:
;;
;;    string test
;;    [string :as str] compiler
;;
;; Each clause is a module name or a module alias form in the form:
;;
;;    [string :as str]
;;
(defn+ comp-require (path0 ctx0 form)
  (case form
    ([]
     ctx0)
    ((module-name . rest)
     (when (erlang/is_atom module-name))
     (case (module-exists? module-name)
       (:true
        (comp-require (incr-path path0) (add-require-ctx module-name ctx0) rest))
       (:false
        (let (idx (idx-from-context [] path0 ctx0))
          (erlang/throw {:invalid-require-clause {:bad-module module-name} idx})))))
    (([module-name [quote as] module-alias]  . rest)
     (when (and (erlang/is_atom module-name)
                (erlang/is_atom module-alias)))
     (case (module-exists? module-name)
       (:true
        (comp-require (incr-path path0)
                      (add-alias-ctx module-alias module-name
                                     (add-require-ctx module-name ctx0))
                      rest))
       (:false
        (let (idx (idx-from-context [] path0 ctx0))
          (erlang/throw {:invalid-require-clause {:bad-module module-name} idx})))))
    (clause
     (let (idx (idx-from-context :traverse path0 ctx0))
       (erlang/throw {:invalid-require-clause clause idx})))))


;; ### Module Body
;;
;;  The module body may consist of any number of require, use are attribute
;;  clauses in any order. Each clause starts with a (require ...)
;;  (use ....) or (attr ...)
;;
(defn+ comp-module-body (path0 ctx0 form)
  (case form
    ([]
     ctx0)
    ((:require . body)
     (comp-require (incr-path path0) ctx0 body))
    ((:attr . body)
     (comp-attr (incr-path path0) ctx0 body))
    ((:use . body)
     (let (idx (idx-from-context [] path0 ctx0))
       (comp-use idx ctx0 body :undefined [])))
    (_
     (let (idx (idx-from-context [] path0 ctx0))
       (erlang/throw {:invalid-form idx})))))

(defn+ comp-module (path0 ctx0 forms)
  (let (path1 (traverse-path path0))
    (case forms
      ((:module . (module-name . rest))
       (let (annots (annots-from-context [] path0 ctx0)
             result (lists/foldl
                     (fn (form acc)
                         (case acc
                           ({path2 ctx1}
                            (let (ctx2 (comp-module-body (traverse-path path2) ctx1 form))
                              {(incr-path path2) ctx2}))))
                     {(incr-path 2 path0) (set-context :module-name module-name
                                                       (set-context :line annots ctx0))} rest))
         (case result
           ({_ ctx3}
            ctx3))))
      (_
       (let (idx (idx-from-context [] path1 ctx0))
         (erlang/throw {:invalid-module-declaration idx}))))))

(defspec comp-expr ((path) (context) (erlang/term)) {(context) (cerl/cerl)})

(defn make-tuple-expr (path0 ctx0 values)
  (case (lists/foldl (fn (val acc0)
                         (case acc0
                           ({path1 ctx1 acc1}
                            (case (comp-expr (traverse-path path1) ctx1 val)
                              ({ctx2 element}
                               {(incr-path path1) ctx2 (element . acc1)})))))
                     {path0 ctx0 []} values)
    ({_ ctx3 body}
     {ctx3 (cerl/ann_c_tuple (annots-from-context [] path0 ctx3)
                             (lists/reverse body))})))
(defn make-seq (path0 ctx0 form)
  (let (annots (annots-from-context :traverse path0 ctx0))
    (case form
      ([arg1 arg2]
       (case (comp-expr (traverse-path path0) ctx0 arg1)
         ({ctx1 cerl-arg1}
          (case (comp-expr (traverse-incr-path path0) ctx1 arg2)
            ({ctx2 cerl-arg2}
             {ctx2 (cerl/ann_c_seq annots cerl-arg1 cerl-arg2)})))))
      ([arg1]
       (comp-expr (traverse-path path0) ctx0 arg1))
      ((arg1 . rest)
       (case (comp-expr (traverse-path path0) ctx0 arg1)
         ({ctx1 cerl-arg1}
          (case (make-seq (incr-path path0) ctx1 rest)
            ({ctx2 cerl-arg2}
             {ctx2 (cerl/ann_c_seq annots cerl-arg1 cerl-arg2)})))))
      ([]
       (erlang/throw {:invalid-sequence (idx-from-context [] path0 ctx0)})))))

(defn make-cons (annots arg1-path arg2-path ctx0 arg1 arg2)
  (case (comp-expr arg1-path ctx0 arg1)
    ({ctx1 cerl-arg1}
     (case (comp-expr arg2-path ctx1 arg2)
       ({ctx2 cerl-arg2}
        {ctx2 (cerl/ann_c_cons annots cerl-arg1 cerl-arg2)})))))

(defn args-to-list (args)
  (case args
    ([]
     (cerl/ann_c_nil [:compiler_generated]))
    ((arg . rest)
     (cerl/ann_c_cons [:compiler_generated]
                      arg
                      (args-to-list rest)))))

(defn args-to-arity (args0 count arity acc)
  (case args0
    ([]
     (lists/reverse acc))
    ((arg . rest)
     (case (erlang/< count arity)
       (:true
         (args-to-arity rest (erlang/+ count 1) arity (arg . acc)))
        (:false
         (args-to-arity [] 0 arity ((args-to-list args0) . acc)))))))

(defn eval-args (path0 ctx0 args0)
  (case (lists/foldl (fn (arg acc0)
                         (case acc0
                           ({path1 ctx1 acc1}
                            (case (comp-expr (traverse-path path1) ctx1 arg)
                              ({ctx2 cerl}
                               {(incr-path path1) ctx2 (cerl . acc1)})))))
                     {path0 ctx0 []} args0)
    ({_ ctx3 args1}
     {ctx3 (lists/reverse args1)})))

(defn add-to-annots (cerl-thing annots)
  (let (old-annots (lists/filter (fn (el)
                                     (case el
                                       ({:rest _}
                                        :true)
                                       ({:not-rest _}
                                        :true)
                                       (_
                                        :false)))
                                 (cerl/get_ann cerl-thing)))
    (cerl/set_ann cerl-thing (lists/append old-annots annots))))

(defn+ gensym ()
  (let (x (erlang/phash2 {(erlang/node) (erlang/now ) (crypto/rand_bytes 16)})
        bit-rep (lists/map (fn (el)
                               (io_lib/format "~.16B" [el]))
                           (erlang/binary_to_list
                            (binary/encode_unsigned x))))
    (erlang/list_to_atom
     (lists/flatten
      (io_lib/format "GENSYM_~s" [bit-rep])))))



(defn is-rest-var? (var)
  (let (annots (cerl/get_ann var))
    (case (lists/keysearch :rest 1 annots)
      ({value val}
       val)
      (_
       (case (lists/keysearch :not-rest 1 annots)
         ({value val}
          val)
         (_
          :unknown))))))


(defn make-rest-apply-var (ctx0 annots cerl-var arg-list)
  (case (is-rest-var? cerl-var)
    ({:rest arity}
     {ctx0 (cerl/ann_c_apply annots
                             cerl-var
                             (args-to-arity arg-list 1 arity []))})
    (_
     {ctx0 (cerl/ann_c_apply annots
                             cerl-var
                             arg-list)})))


(defn make-apply (path0 ctx0 form)
  (let (annots (annots-from-context [] path0 ctx0))
    (case form
      ((:apply . (target . args))
       (case (eval-args (incr-path 2 path0) ctx0 args)
         ({ctx1 arg-list}
          (case (resolve-reference-ctx target (erlang/length args) ctx0)
            ({:remote {module function arity}}
             (case (eval-args (incr-path 2 path0) ctx0 args)
               ({ctx1 arg-list}
                {ctx1 (cerl/ann_c_call annots
                                       (cerl/ann_c_atom annots module)
                                       (cerl/ann_c_atom annots function)
                                       arg-list)})))
            ({:remote-rest module function arity}
             {ctx1 (cerl/ann_c_call annots
                                    (cerl/ann_c_atom annots module)
                                    (cerl/ann_c_atom annots function)
                                    (args-to-arity arg-list 1 arity []))})
            ({:apply {function arity}}
             {(add-fun-dep-ctx function arity ctx1)
              (cerl/ann_c_apply annots
                                (cerl/ann_c_fname annots function arity)
                                arg-list)})
            ({:apply-rest {function arity}}
             {(add-fun-dep-ctx function arity ctx1)
              (cerl/ann_c_apply annots
                                (cerl/ann_c_fname annots function arity)
                                (args-to-arity arg-list 1 arity []))})

            ({:reference {val _}}
             (make-rest-apply-var ctx1 annots val arg-list))
            (:not-a-reference
             (case (comp-expr (traverse-path path0) ctx1 target)
               ({ctx2 cerl-val}
                {ctx2 (cerl/ann_c_apply annots
                                        cerl-val
                                        arg-list)})))))))
      (_
       (erlang/throw {:invalid-reference form
                                         (idx-from-context [] path0 ctx0)})))))

(defn make-apply-rest-fun (ctx0 f-var arity rest-arity)
  (let (arg-list (lists/map (fn (_)
                                (cerl/ann_c_var [:compiler_generated]
                                                (gensym)))
                            (lists/seq 1 arity))
        annots [:compiler_generated])

    {(incr-fun-index-ctx ctx0)
     (cerl/ann_c_fun annots arg-list
                     (cerl/ann_c_apply annots
                                     f-var
                                     (args-to-arity arg-list 1 rest-arity [])))}))

(defn make-remote-rest-fun (ctx0 module function arity rest-arity)
  (let (arg-list (lists/map (fn (_)
                                (cerl/ann_c_var [:compiler_generated]
                                                (gensym)))
                            (lists/seq 1 arity))
                 annots [:compiler_generated])

    {(incr-fun-index-ctx ctx0)
     (cerl/ann_c_fun annots arg-list
                     (cerl/ann_c_call annots
                                      (cerl/ann_c_atom annots module)
                                      (cerl/ann_c_atom annots function)
                                      (args-to-arity arg-list 1 rest-arity [])))}))


(defn make-fun (path0 ctx0 form)
  (let (annots (annots-from-context [] path0 ctx0))
    (case form
      ({:--fun f a} (when (erlang/is_integer a))
       (case (resolve-reference-ctx f a ctx0)
         ({:reference {var _}}
          (case (erlang/and (cerl/is_c_fname var)
                            (== (cerl/fname_arity var) a))
            (:true
             {ctx0 (add-to-annots var annots)})
            (:false
             (let (idx (idx-from-context [] path0 ctx0))
               (erlang/throw {:invalid-reference {f a} idx})))))
         ({:apply {name a}}
          {(add-fun-dep-ctx name a ctx0)
           (cerl/ann_c_fname annots name a)})
         ({:apply-rest {name rest-arity}}
          (make-apply-rest-fun (add-fun-dep-ctx name rest-arity ctx0)
                               (cerl/ann_c_fname annots name a)
                               a rest-arity))
         (_
          (let (idx (idx-from-context [] path0 ctx0))
            (erlang/throw {:invalid-reference {f a} idx})))))
      ((= ref {:--fun _ _ a})
       (when (erlang/is_integer a))
       (case (resolve-reference-ctx ref a ctx0)
         ({:reference {_ _}}
          (erlang/throw {:invalid-reference (idx-from-context [] path0 ctx0)}))
         ({:remote {module function arity}}
          (when (erlang/and (erlang/is_atom module)
                            (erlang/is_atom function)))
          {ctx0 (cerl/ann_c_call annots
                                 (cerl/ann_c_atom annots
                                                  :erlang)
                                 (cerl/ann_c_atom annots
                                                  :make_fun)
                                 [(cerl/ann_c_atom annots module)
                                  (cerl/ann_c_atom annots function)
                                  (cerl/ann_c_int annots arity)])})
         ({:remote-rest {module function rest-arity}}
          (when (erlang/and (erlang/is_atom module)
                            (erlang/is_atom function)))
          (make-remote-rest-fun ctx0 module function a rest-arity))
         (_
          (erlang/throw {:undefined-reference ref (idx-from-context [] path0 ctx0)}))))
      (_
       (erlang/throw {:undefined-reference form (idx-from-context [] path0 ctx0)})))))

(defn make-list (path0 ctx0 form)
  (let (annots (annots-from-context :traverse path0 ctx0))
    (case form
      ([]
       {ctx0 (cerl/c_nil)})
      ((h . t)
       (case (comp-expr (traverse-path path0) ctx0 h)
         ({ctx1 cerl-h}
          (case (make-list (incr-path path0)  ctx1 t)
            ({ctx2 cerl-t}
             {ctx2 (cerl/ann_c_cons annots cerl-h cerl-t)}))))))))


(defn make-call (path0 ctx0 val args)
  (let (annots (annots-from-context [] path0 ctx0))
    (let (possible-arity (erlang/length args)
          path1 (traverse-path path0)
          call-annots (annots-from-context [] path1 ctx0))
      (case (eval-args (incr-path path0) ctx0 args)
        ({ctx1 arg-list}
         (case (resolve-reference-ctx val possible-arity ctx1)
           ({:reference {var _}}
            (make-rest-apply-var ctx1 annots (add-to-annots var annots) arg-list))
           ({:apply {name arity}}
            {(add-fun-dep-ctx name arity ctx1)
             (cerl/ann_c_apply annots
                               (cerl/ann_c_fname call-annots
                                                 name
                                                 arity)
                               arg-list)})
           ({:apply-rest {name arity}}
            {(add-fun-dep-ctx name arity ctx1)
             (cerl/ann_c_apply annots
                               (cerl/ann_c_fname call-annots
                                                 name
                                                 arity)
                               (args-to-arity arg-list 1 arity []))})
           ({:remote {module function possible-arity}}
                 {ctx1 (cerl/ann_c_call annots
                           (cerl/ann_c_atom call-annots
                                            module)
                           (cerl/ann_c_atom call-annots
                                            function)
                           arg-list)})
           ({:remote-rest {module function arity}}
                 {ctx1 (cerl/ann_c_call annots
                           (cerl/ann_c_atom call-annots
                                            module)
                           (cerl/ann_c_atom call-annots
                                            function)
                            (args-to-arity arg-list 1 arity []))})
           ({:error error}
            (erlang/throw {error (idx-from-context [] path0 ctx1)}))
           (:not-a-reference
            (when (erlang/is_list val))
            (case (comp-expr (traverse-path path0) ctx1 val)
              ({ctx2 cerl-val}
               (make-rest-apply-var ctx2 annots (add-to-annots cerl-val annots) arg-list))))
           (:not-a-reference
            (case (resolve-reference-ctx val -1 ctx1)
              ({:reference {var _}}
               (make-rest-apply-var ctx1 annots (add-to-annots var annots) arg-list))
              (_
               (erlang/throw {:invalid-reference val possible-arity
                                                 (idx-from-context [] path0 ctx1)}))))))))))

(defn make-try (path0 ctx0 form)
  (let (annots (annots-from-context [] path0 ctx0))
    (case form
      ([:__try expr [:catch [type value] catch-expr]]
       (when (erlang/and (erlang/is_atom type)
                         (erlang/is_atom value)))
       (case (comp-expr (traverse-incr-path path0) ctx0 expr)
         ({ctx1 cerl-expr}
          (let (try-var (cerl/ann_c_var (:compiler_generated . annots) (gensym))
                type-var (cerl/ann_c_var annots type)
                value-var (cerl/ann_c_var annots value)
                ignore-var (cerl/ann_c_var (:compiler_generated . annots) (gensym))
                ctx2 (add-reference-to-scope-ctx
                      type -1
                      type-var
                      path0
                      (add-reference-to-scope-ctx value -1 value-var
                                                  path0 (push-scope-ctx ctx1))))
            (case (comp-expr (incr-path (traverse-incr-path 2 path0)) ctx2 catch-expr)
              ({ctx3 cerl-catch}
               {(pop-scope-ctx ctx2)
                (cerl/ann_c_try annots cerl-expr [try-var] try-var
                                [type-var value-var ignore-var]
                                cerl-catch)}))))))
      (_
       (erlang/throw {:invalid-try-expression (idx-from-context [] path0 ctx0)})))))

(defn get-bitstring (field bit)
  (case field
    (:var (erlang/element 2 bit))
    (:size (erlang/element 3 bit))
    (:unit (erlang/element 4 bit))
    (:type (erlang/element 5 bit))
    (:signedness (erlang/element 6 bit))
    (:endianness (erlang/element 7 bit))
    (_ (erlang/throw {:invalid-field :bitstring field}))))

(defn set-bitstring (field value bit)
  (case field
    (:var (erlang/setelement 2 bit value))
    (:size (erlang/setelement 3 bit value))
    (:unit (erlang/setelement 4 bit value))
    (:type (erlang/setelement 5 bit value))
    (:signedness (erlang/setelement 6 bit value))
    (:endianness (erlang/setelement 7 bit value))
    (_ (erlang/throw {:invalid-field :bitstring field}))))

(defn new-bitstring ()
  {:bitstring
   :undefined
   :undefined
   :undefined
   :integer
   :unsigned
   :big})

(defn resolve-bitstring-defaults (idx value)
  (case value
    (:invalid
     (erlang/throw {:invalid-bitstring-spec idx}))
    (_
     (let (annots '(compiler_generated)
                  size0 (get-bitstring :size value)
                  unit0 (get-bitstring :unit value)
                  type0 (get-bitstring :type value)
                  size1 (case size0
                          (:undefined
                           (case type0
                             (:integer 8)
                             (:float 64)
                             (:binary [:quote :all])
                             (:bitstring 1)
                             (:bits 1)
                             (:utf8 [:quote :undefined])
                             (:utf16 [:quote :undefined])
                             (:utf32 [:quote :undefined])))
                          (val
                           val))
                  unit1 (case unit0
                          (:undefined
                           (case type0
                             (:float (cerl/ann_c_int annots 1))
                             (:integer (cerl/ann_c_int annots 1))
                             (:bitstring (cerl/ann_c_int annots 1))
                             (:bits (cerl/ann_c_int annots 1))
                             (:binary (cerl/ann_c_int annots 8))
                             (:utf8 (cerl/ann_c_int annots :undefined))
                             (:utf16 (cerl/ann_c_int annots :undefined))
                             (:utf32 (cerl/ann_c_int annots :undefined))))
                          (val
                           (when (erlang/is_integer val))
                           (cerl/ann_c_int annots val))))
       (set-bitstring :size size1
                      (set-bitstring :unit unit1 value))))))

(defn convert-bitstring (pairs bitstring)
  (case pairs
    (([:quote :size] . (value . rest))
     (convert-bitstring rest (set-bitstring :size value bitstring)))
    (([:quote :unit] . (value . rest))
     (convert-bitstring rest (set-bitstring :unit value bitstring)))
    (([:qute :little] . rest)
     (convert-bitstring rest (set-bitstring :endianness :little bitstring)))
    (([:quote :big] . rest)
     (convert-bitstring rest (set-bitstring :endianness :big bitstring)))
    (([:quote :native] . rest)
     (convert-bitstring rest (set-bitstring :endianness :native bitstring)))
    (([:quote :signed] . rest)
     (convert-bitstring rest (set-bitstring :signedness :signed bitstring)))
    (([:quote :unsigned] . rest)
     (convert-bitstring rest (set-bitstring :signedness :unsigned bitstring)))
    (([:quote :integer] . rest)
     (convert-bitstring rest (set-bitstring :type :integer bitstring)))
    (([:quote :binary] . rest)
     (convert-bitstring rest (set-bitstring :type :binary bitstring)))
    (([:quote :utf8] . rest)
     (convert-bitstring rest (set-bitstring :type :utf8 bitstring)))
    (([:quote :utf16] . rest)
     (convert-bitstring rest (set-bitstring :type :utf16 bitstring)))
    (([:quote :utf32] . rest)
     (convert-bitstring rest (set-bitstring :type :utf32 bitstring)))
    (([:quote :float] . rest)
     (convert-bitstring rest (set-bitstring :type :float bitstring)))
    ([]
     bitstring)
    (_
     :invalid)))

(defn make-binary-element (element acc0)
  (case acc0
    ({path0 ctx0 acc1}
     (let (idx (idx-from-context [] path0 ctx0))
       (case element
         ((var . pairs0)
          (let (path1 (traverse-path path0)
                bitstring
                (resolve-bitstring-defaults idx
                                            (convert-bitstring pairs0
                                                               (new-bitstring)))
                annots (annots-from-context :traverse path1 ctx0))
            (case (comp-expr path1 ctx0 var)
              ({ctx1 cerl-var}
               (case (comp-expr path1 ctx1 (get-bitstring :size bitstring))
                 ({ctx2 size}
                  {(incr-path path1)
                   ctx2
                   ((cerl/ann_c_bitstr annots
                                       cerl-var
                                       size
                                       (get-bitstring :unit bitstring)
                                       (cerl/ann_c_atom annots
                                                        (get-bitstring :type bitstring))
                                       (cerl/ann_make_list annots
                                                           [(cerl/ann_c_atom annots
                                                                             (get-bitstring :signedness bitstring))
                                                            (cerl/ann_c_atom annots
                                                                             (get-bitstring :endianness bitstring))]))
                    . acc1)}))))))
         (var (when (erlang/or (erlang/is_atom  var)
                               (erlang/is_integer var)))
              (let (annots (annots-from-context :traverse path0 ctx0)
                    bitstring (resolve-bitstring-defaults idx (new-bitstring)))
                (case (comp-expr path0 ctx0 var)
                  ({ctx1 cerl-var}
                   (case (comp-expr path0 ctx1 (get-bitstring :size bitstring))
                     ({ctx2 size}
                      {(incr-path path0)
                       ctx2
                       ((cerl/ann_c_bitstr annots
                                           cerl-var
                                           size
                                           (get-bitstring :unit bitstring)
                                           (cerl/ann_c_atom annots (get-bitstring :type bitstring))
                                           (cerl/ann_make_list annots
                                                               [(cerl/ann_c_atom annots
                                                                                 (get-bitstring :signedness bitstring))
                                                                (cerl/ann_c_atom annots
                                                                                 (get-bitstring :endianness bitstring))]))
                        . acc1)}))))))
         (_
          (erlang/throw {:invalid-bitstring idx})))))))

(defn make-binary (path0 ctx0 form)
  (let (annots (annots-from-context [] path0 ctx0))
    (case form
      ((:binary . args)
       (case (lists/foldl make-binary-element/2 {(incr-path path0) ctx0 []} args)
         ({_ ctx1 acc}
          {ctx1 (cerl/ann_c_binary annots (lists/reverse acc))}))))))

(defn get-expr-arity (expr)
  (case (cerl/type expr)
    (:var
     (case (cerl/fname_arity expr)
       (:undefined
        -1)
       (arity (when (erlang/is_integer arity))
              arity)))
    (:fun
     (cerl/fun_arity expr))
    (_ -1)))

(defn arg-arity (args count)
  (case args
    ([]
     {[{:not-rest count}] count})
    ((:&rest . _)
     {[{:rest (+ count 1)}]  (+ count 1)})
    ((_ . rest)
     (arg-arity rest (+ count 1)))))

(defn make-let-binding (body-path0 binding-path0 ctx0 var expr continuation)
  (let (binding-path1 (traverse-path binding-path0)
        annots (annots-from-context [] binding-path1 ctx0))
    (case expr
      ((:fn . (args . _))
       (case (arg-arity args 0)
         ({new-annots arity}
          (let (fn-annots (lists/append annots new-annots)
                cerl-var (cerl/ann_c_fname fn-annots var arity)
                ctx1 (add-reference-to-scope-ctx
                      var
                      arity
                      cerl-var
                      binding-path1
                      (push-scope-ctx ctx0)))
            (case (comp-expr (traverse-incr-path binding-path0) ctx1 expr)
              ({ctx3 cerl-expr}
               (case (continuation body-path0 (incr-path binding-path0) ctx3)
                 ({ctx4 cerl-body}
                  {(pop-scope-ctx ctx4) (cerl/ann_c_letrec annots
                                                           [{cerl-var cerl-expr}]
                                                           cerl-body)}))))))))
      (_
       (case (comp-expr (traverse-incr-path binding-path0)
                        ctx0
                        expr)
         ({ctx1 cerl-expr}
          (let (ctx2 (add-reference-to-scope-ctx var (get-expr-arity cerl-expr)
                                                 (cerl/ann_c_var annots var)
                                                 binding-path1
                                                 (push-scope-ctx ctx1)))
            (case (continuation  body-path0 (incr-path binding-path0) ctx2)
              ({ctx4 cerl-body}
               {(pop-scope-ctx ctx4) (cerl/ann_c_let annots
                                                     [(cerl/ann_c_var annots var)]
                                                     cerl-expr
                                                     cerl-body)})))))))))

(defn make-let-bindings (body-path0 binding-path0 ctx0 bindings body)
  (case bindings
    ([var expr]
     (make-let-binding body-path0 binding-path0 ctx0 var expr
                       (fn (body-path1 binding-path1 ctx1)
                           (make-seq body-path1  ctx1 body))))
    ((var . (expr . rest))
     (make-let-binding body-path0 binding-path0 ctx0 var expr
                       (fn (body-path1 binding-path1 ctx1)
                           (make-let-bindings body-path1
                                              (incr-path binding-path1)
                                              ctx1 rest body))))
    (_
     (erlang/throw {:invalid-let-binding
                    (idx-from-context [] binding-path0 ctx0)}))))


(defn make-let (path0 ctx0 form)
  (let (path1 (traverse-incr-path path0))
    (case form
      ((:let . (bindings . body))
       (make-let-bindings (incr-path 2 path0) path1 ctx0 bindings body))
      (_
       (erlang/throw {:invalid-form (idx-from-context [] path0 ctx0)})))))


(defn valid-guard (module function arity)
  (case {module function arity}
    ({:erlang :abs 1} :true)
    ({:erlang :bitsize 1} :true)
    ({:erlang :byte_size 1} :true)
    ({:erlang :element 2} :true)
    ({:erlang :float 1} :true)
    ({:erlang :hd 1} :true)
    ({:erlang :length 1} :true)
    ({:erlang :node 0} :true)
    ({:erlang :node 1} :true)
    ({:erlang :round 1} :true)
    ({:erlang :self 0} :true)
    ({:erlang :size 1} :true)
    ({:erlang :tl 1} :true)
    ({:erlang :trunc 1} :true)
    ({:erlang :tuple_size 1} :true)
    ({:erlang :is_binary 1} :true)
    ({:erlang :is_alive 0} :true)
    ({:erlang :is_boolean 1} :true)
    ({:erlang :is_function 1} :true)
    ({:erlang :is_function 2} :true)
    ({:erlang :is_integer 1} :true)
    ({:erlang :is_float 1} :true)
    ({:erlang :is_list 1} :true)
    ({:erlang :is_atom 1} :true)
    ({:erlang :is_number 1} :true)
    ({:erlang :is_pid 1} :true)
    ({:erlang :is_port 1} :true)
    ({:erlang :is_record 2} :true)
    ({:erlang :is_record 3} :true)
    ({:erlang :is_reference 1} :true)
    ({:erlang :is_tuple 1} :true)
    ({:erlang :and 2} :true)
    ({:erlang :or 2} :true)
    ({:erlang :> 2} :true)
    ({:erlang :< 2} :true)
    ({:erlang :== 2} :true)
    ({:erlang :=< 2} :true)
    ({:erlang :>= 2} :true)
    ({:erlang :/= 2} :true)
    ({:erlang :=:= 2} :true)
    ({:erlang :=/= 2} :true)
    (_ :false)))

(defn check-guards (ast)
  (case (cerl/type ast)
    (:call
     (erlang/and (valid-guard (cerl/atom_val (cerl/call_module ast))
                              (cerl/atom_val (cerl/call_name ast))
                              (cerl/call_arity ast))
                 (lists/all check-guards/1 (cerl/call_args ast))))
    (:cons
     (erlang/and (check-guards (cerl/cons_hd ast))
                 (check-guards (cerl/cons_tl ast))))
    (:binary :true)
    (:bitstring :true)
    (:tuple (lists/all check-guards/1 (cerl/tuple_es ast)))
    (:var :true)
    (:literal :true)
    (_ :false)))

(defn check-guards (idx ast)
  (case (check-guards ast)
    (:true ast)
    (:false
     (erlang/throw {:invalid-guard idx}))))


(defn make-guards (annots guards)
  (case guards
    ([]
     (cerl/ann_c_atom annots :true))
    ([guard]
     guard)
    ((pattern . rest)
     (cerl/ann_c_call annots
                      (cerl/ann_c_atom annots :erlang)
                      (cerl/ann_c_atom annots :and)
                      [pattern (make-guards annots rest)]))))

(defn make-pattern-var (path0 ctx0 guards0 var0)
  (let (annots (:compiler_generated .
                                    (annots-from-context [] path0 ctx0)))
    (case (resolve-reference-ctx var0 -1 ctx0)
      ({:reference {var1 _}}
       ;; The reference already exists. So we create a new variable and
       ;; add a guard for to test for equality
       (let (gensym (gensym)
             cerl-var (cerl/ann_c_var annots gensym)
             guards1 ((cerl/ann_c_call annots
                                       (cerl/ann_c_atom [:compiler_generated]
                                                        :erlang)
                                              (cerl/ann_c_atom annots
                                                               :=:=)
                                              [cerl-var (add-to-annots var1 annots)])
                      . guards0))
         ;; We don't add the generated variable to the scope as we
         ;; don't want it to be available to the user (The user really
         ;; should not even be aware of it)
         {ctx0 guards1 cerl-var}))
      (_
       (let (annots-bare (annots-from-context [] path0 ctx0)
                         ;; The variable is not in the scope so we turn it to a
                         ;; variable
             cerl-var (cerl/ann_c_var annots-bare var0)
             ctx1 (add-reference-to-scope-ctx var0 -1 cerl-var path0 ctx0))
         {ctx1 guards0 cerl-var})))))

(defspec make-pattern-element ((path) (context) [(erlang/term)] (erlang/term))
  {(context) (erlang/term) (cerl/cerl)})

(defn make-pattern-alias (alias-path pattern-path ctx0 guards0 alias pattern)
  (let (alias-annots (annots-from-context [] alias-path ctx0)
        pattern-annots (annots-from-context [] pattern-path ctx0)
        alias-var (cerl/ann_c_var alias-annots alias))
    (case (make-pattern-element (traverse-incr-path pattern-path)
                                ctx0 guards0 pattern)
      ({ctx1 guards1 cerl-pattern}
       (case (resolve-reference-ctx alias -1 ctx0)
         (:not-a-reference
          {(add-reference-to-scope-ctx alias -1 alias-var alias-path ctx1)
           guards1
           (cerl/ann_c_alias alias-annots alias-var cerl-pattern)})
         (_
          (erlang/throw {:reference-already-defined alias
                                                    (idx-from-context [] alias-path ctx0)})))))))

(defn make-binary-pattern-element (arg acc0)
  (case acc0
    ({path0 ctx0 guards0 acc1}
     (let (annots (annots-from-context [] path0 ctx0)
           idx (idx-from-context [] path0 ctx0))
       (case arg
         ((var . pairs0)
          (let (path1 (traverse-path path0)
                bitstring  (resolve-bitstring-defaults idx
                                                       (convert-bitstring pairs0 (new-bitstring))))
            (case (make-pattern-element path1 ctx0 guards0 var)
              ({ctx1 guards1 cerl-var}
               (case (comp-expr path1 ctx1 (get-bitstring :size bitstring))
                 ({ctx2 size}
                  {(incr-path path1) ctx2 guards1
                   ((cerl/ann_c_bitstr annots
                                       cerl-var
                                       size
                                       (get-bitstring :unit bitstring)
                                       (cerl/ann_c_atom annots (get-bitstring :type bitstring))
                                       (cerl/ann_make_list annots
                                                           [(cerl/ann_c_atom annots
                                                                             (get-bitstring :signedness bitstring))
                                                            (cerl/ann_c_atom annots
                                                                             (get-bitstring :endianness bitstring))]))
                    . acc1)}))))))
         (var (when (erlang/or (erlang/is_atom var)
                               (erlang/is_integer var)))
              (let (bitstring (resolve-bitstring-defaults idx (new-bitstring)))
                (case (make-pattern-element path0 ctx0 guards0 var)
                  ({ctx1 guards1 cerl-var}
                   (case (comp-expr path0 ctx1 (get-bitstring :size bitstring))
                     ({ctx2 size}
                      {(incr-path path0)
                       ctx2 guards1
                       ((cerl/ann_c_bitstr annots
                                           cerl-var
                                           size
                                           (get-bitstring :unit bitstring)
                                           (cerl/ann_c_atom annots (get-bitstring :type bitstring))
                                           (cerl/ann_make_list annots
                                                               [(cerl/ann_c_atom annots
                                                                                 (get-bitstring :signedness bitstring))
                                                                (cerl/ann_c_atom annots
                                                                                 (get-bitstring :endianness bitstring))])) . acc1)}))

                   ))))
         (_
          (erlang/throw {:invalid-bitstring idx})))))))

(defn make-binary-pattern (path0 ctx0 guards0 pairs)
  (case (lists/foldl make-binary-pattern-element/2
                     {(incr-path path0) ctx0 guards0 []} pairs)
    ({_ ctx1 guards1 acc}
     {ctx1 guards1 (cerl/ann_c_binary (annots-from-context [] path0 ctx0)
                                      (lists/reverse acc))})))

(defn make-pattern-tuple (path0 ctx0 guards0 args)
  (let (annots (annots-from-context [] path0 ctx0))
    (case (lists/foldl (fn (arg acc0)
                           (case acc0
                             ({path1 ctx1 guards1 acc1}
                              (case (make-pattern-element (traverse-path path1) ctx1 guards1 arg)
                                ({ctx2 guards2 element}
                                 {(incr-path path1)
                                  ctx2 guards2 (element . acc1)})))))
                       {path0 ctx0 guards0 []} args)
      ({_ ctx3 guards3 acc}
       {ctx3 guards3 (cerl/ann_c_tuple annots (lists/reverse acc))}))))

(defn make-pattern-list (path0 ctx0 guards0 l)
  (let (annots (annots-from-context [] path0 ctx0))
    (case l
      ([]
       {ctx0 guards0 (cerl/c_nil)})
      ((h . t)
       (case (make-pattern-element (traverse-path path0) ctx0 guards0 h)
         ({ctx1 guards1 cerl-h}
          (case (make-pattern-list (incr-path path0) ctx1 guards1 t)
            ({ctx2 guards2 cerl-t}
             {ctx2 guards2 (cerl/ann_c_cons annots cerl-h cerl-t)}))))))))

(defn make-literal-string (_path0 annots _ctx0 string)
  (cerl/ann_c_string annots string))

(defn make-pattern-element (path0 ctx0 guards0 arg0)
  (let (annots (annots-from-context [] path0 ctx0))
    (case arg0
      (arg0 (when (erlang/is_binary arg0))
            {ctx0 guards0 (cerl/ann_make_data annots {:atomic arg0} [])})
      (:_
       (let (gensym (erlang/list_to_atom (lists/append "_"
                                                       (erlang/atom_to_list (gensym))))
             cerl-var (cerl/ann_c_var annots gensym)
             ctx1 (add-reference-to-scope-ctx gensym -1 cerl-var path0 ctx0))
         {ctx1 guards0 cerl-var}))
      (arg0 (when (erlang/is_atom arg0))
            (make-pattern-var path0 ctx0 guards0 arg0))
      (arg0 (when (erlang/is_integer arg0))
            {ctx0 guards0 (cerl/ann_c_int annots arg0)})
      (arg0 (when (erlang/is_float arg0))
            {ctx0 guards0 (cerl/ann_c_float annots arg0)})
      (args0 (when (erlang/is_tuple args0))
             (make-pattern-tuple path0 ctx0 guards0 (erlang/tuple_to_list args0)))
      ([:= alias pattern] (when (erlang/is_atom alias))
       (make-pattern-alias (incr-path path0) (traverse-incr-path 2 path0)
                           ctx0 guards0 alias pattern))
      ([:= pattern alias] (when (erlang/is_atom alias))
       (make-pattern-alias (traverse-incr-path 2 path0) (incr-path path0)
                           ctx0 guards0 alias pattern))
      ([:quote args]
       (let (literal (make-literal (traverse-incr-path path0) ctx0 args))
         {ctx0 guards0 literal}))
      ([:string str0]
       (let (literal (make-literal-string (traverse-incr-path path0) annots ctx0 str0))
         {ctx0 guards0 literal}))
      ((:binary . pairs)
       (make-binary-pattern path0 ctx0 guards0 pairs))
      ((:list . args)
       (make-pattern-list (incr-path path0) ctx0 guards0 args))
      ((:tuple . args)
       (make-pattern-tuple (incr-path path0) ctx0 guards0 args))
      ([arg1 :. arg2]
       (case (make-pattern-element (traverse-path path0) ctx0 guards0 arg1)
         ({ctx1 guards1 cerl-arg1}
          (case (make-pattern-element (traverse-incr-path 2 path0)
                                      ctx1 guards1 arg2)
            ({ctx2 guards2 cerl-arg2}
             {ctx2 guards2 (cerl/ann_c_cons annots cerl-arg1 cerl-arg2)})))))
      ([:cons arg1 arg2]
       (case (make-pattern-element (traverse-incr-path path0) ctx0 guards0 arg1)
         ({ctx1 guards1 cerl-arg1}
          (case (make-pattern-element (traverse-incr-path 2 path0)
                                      ctx1 guards1 arg2)
            ({ctx2 guards2 cerl-arg2}
             {ctx2 guards2 (cerl/ann_c_cons annots cerl-arg1 cerl-arg2)})))))
      (_
       (erlang/throw {:invalid-pattern (idx-from-context [] path0 ctx0)})))))

(defn make-pattern-clause-body (path0 ctx0 form)
  (let (ctx1 (push-scope-ctx ctx0)
        annots (annots-from-context [] path0 ctx0))
    (case form
      ((pattern . ([:when guards] . body))
       (case (make-pattern-element (traverse-path path0) ctx1 [] pattern)
         ({ctx2 pattern-guards cerl-pattern}
          (let (guard-annots (annots-from-context []
                                                  (traverse-incr-path path0) ctx2)
                guard-idx (idx-from-context [] (traverse-incr-path path0) ctx2))
            (case (comp-expr (traverse-incr-path (traverse-incr-path path0)) ctx2 guards)
              ({ctx3 cerl-guard}
               (case (make-seq (incr-path 2 path0) ctx3 body)
                 ({ctx4 cerl-body}
                  {(pop-scope-ctx ctx4)
                   (cerl/ann_c_clause annots
                                      [cerl-pattern]
                                      (check-guards guard-idx
                                                    (make-guards guard-annots
                                                                 (cerl-guard . pattern-guards)))
                                      cerl-body)}))))))))
      ((pattern . body)
       (case (make-pattern-element (traverse-path path0) ctx1 [] pattern)
         ({ctx2 pattern-guards cerl-pattern}
          (case (make-seq (incr-path path0) ctx2 body)
            ({ctx3 cerl-body}
             {(pop-scope-ctx ctx3)
              (cerl/ann_c_clause annots
                                 [cerl-pattern]
                                 (make-guards annots pattern-guards)
                                 cerl-body)})))))
      (_
       (erlang/throw {:invalid-case-clause (idx-from-context [] path0 ctx0)})))))

(defn do-clause-terminator (path0 ctx0 clause)
  (case (make-pattern-clause-body (traverse-path path0) ctx0 clause)
    ({ctx1 actual-clause}
     (let (annots (:compiler_generated . (annots-from-context [] path0 ctx0))
           var (gensym))
       {ctx1
        actual-clause
        [(cerl/ann_c_clause annots
                            [(cerl/ann_c_var annots var)]
                            (cerl/ann_c_primop annots
                                               (cerl/ann_c_atom annots :match_fail)
                                               [(cerl/ann_c_tuple annots
                                                                  [(cerl/ann_c_atom annots :case_clause)
                                                                   (cerl/ann_c_var annots var)])]))]}))))

(defn make-pattern (path0 ctx0 form acc)
  (case form
    ([]
     (erlang/throw {:no-clauses-provided (idx-from-context [] path0 ctx0)}))
    ([clause]
     (case (do-clause-terminator path0 ctx0 clause)
       ({ctx1 clauses special-terminator}
        {ctx1 (lists/append (lists/reverse (clauses . acc)) special-terminator)})))
    ((clause . rest)
     (case (make-pattern-clause-body (traverse-path path0) ctx0 clause)
       ({ctx1 clauses}
        (make-pattern (incr-path path0) ctx1 rest (clauses . acc)))))))

(defn gen-args (path0 ctx0 arg-list acc)
  (let (annots
        (annots-from-context :traverse path0 ctx0))
    (case arg-list
      ([:&rest rest-arg]
       {ctx0 (lists/reverse ((cerl/ann_c_var annots rest-arg) . acc)) :true})
      ((:&rest . rest-arg)
       (erlang/throw {:invalid-arguments (idx-from-context [] path0 ctx0)}))
      ((a . rest) (when (erlang/is_atom a))
       (gen-args (incr-path path0) ctx0 rest ((cerl/ann_c_var annots a) . acc)))
      ([]
       {ctx0 (lists/reverse acc) :false}))))

(defn make-fun-body (path0 ctx0 is-anon arg-list expressions)
  (case (make-seq (incr-path path0) ctx0 expressions)
    ({ctx1 body}
     {(case is-anon
        (:true (incr-fun-index-ctx (pop-scope-ctx ctx1) ))
        (:false (pop-scope-ctx ctx1)))
      arg-list body})))

(defn make-rest-fun-body (path0 ctx0 is-anon name arg-list expressions)
  (case (make-fun-body path0 ctx0 is-anon arg-list expressions)
    ({ctx1 arg-list body}
     (case is-anon
       (:false
        {(add-rest-ctx name (erlang/length arg-list) ctx1) arg-list body})
       (:true
        (let (index (get-context :anon-fun-index ctx1))
          {(add-rest-ctx {:anon index} (erlang/length arg-list) ctx1)
           arg-list
           body}))))))

(defn do-function-body (path0 ctx0 is-anon name args0 expressions)
  (case (lists/foldl (fn (el, acc0)
                         (let (arg (case el
                                     ([_ arg]
                                      arg)
                                     (_
                                      el)))
                           (case acc0
                             ({ctx1 acc1}
                              {(add-reference-to-scope-ctx arg -1 (cerl/c_var arg) path0 ctx1)
                               (arg . acc1)}))))
                     {(push-scope-ctx ctx0)  []} args0)
    ({ctx2 args1}
     (case (gen-args (traverse-path path0) ctx2 (lists/reverse args1) [])
       ({ctx3 arg-list :true}
        (make-rest-fun-body path0 ctx3 is-anon name arg-list expressions))
       ({ctx3 arg-list :false}
        (make-fun-body path0 ctx3 is-anon arg-list expressions))))))

(defn comp-expr (path0 ctx0 form)
  (let (annots (annots-from-context [] path0 ctx0))
    (case form
      (arg (when (erlang/is_binary arg))
           {ctx0 (cerl/ann_make_data annots {:atomic arg} [])})
      (arg (when (erlang/is_integer arg))
           {ctx0 (cerl/ann_c_int annots arg)})
      (arg (when (erlang/is_float arg))
           {ctx0 (cerl/ann_c_float annots arg)})
      (arg (when (erlang/is_atom arg))
           (case (resolve-reference-ctx arg -1 ctx0)
             ({:reference {var _}}
              {ctx0 (add-to-annots var annots)})
             (e
              (let (idx (idx-from-context [] path0 ctx0))
                (erlang/throw {:invalid-reference e arg idx})))))
      (arg (when (erlang/and
                  (erlang/is_tuple arg)
                  (== (erlang/element 1 arg) :--fun)))
           (make-fun path0 ctx0 form))
      (arg (when (erlang/is_tuple arg))
           (make-tuple-expr path0 ctx0 (erlang/tuple_to_list arg)))
      ((:let . _)
       (make-let path0 ctx0 form))
      ((:case . (expr . clauses))
       (case (comp-expr (traverse-incr-path path0) ctx0 expr)
         ({ctx1 cerl-expr}
          (case (make-pattern (incr-path 2 path0) ctx1 clauses [])
            ({ctx2 cerl-clauses}
             {ctx2 (cerl/ann_c_case annots cerl-expr cerl-clauses)})))))
      ((:do . args)
       (make-seq (incr-path path0) ctx0 args))
      ((:binary . _)
       (make-binary path0 ctx0 form))
      ([arg1 :. arg2]
       (make-cons annots (traverse-path path0) (traverse-incr-path 2 path0)
                  ctx0 arg1 arg2))
      ([:cons arg1 arg2]
       (make-cons annots (incr-path path0) (incr-path 2 path0) ctx0 arg1 arg2))
      ((:apply . _)
       (make-apply path0 ctx0 form))
      ([:quote args]
       (let (literal (make-literal (traverse-incr-path path0) ctx0 args))
         {ctx0 literal}))
      ([:string args]
       (let (literal (make-literal-string (traverse-incr-path path0) annots ctx0 args))
         {ctx0 literal}))
      ((:list . args)
       (make-list (incr-path path0) ctx0 args))
      ((:tuple . args)
       (make-tuple-expr (incr-path path0) ctx0 args))
      ((:__try . _)
       (make-try path0 ctx0 form))
      ((:fn . fn-body)
       (case fn-body
         ((args . expression)
          (case (do-function-body (incr-path path0) ctx0 :true :anon args expression)
            ({ctx1 arg-list body}
             {ctx1 (cerl/ann_c_fun annots arg-list body)})
            (_
             (erlang/throw {:invalid-fn-form (idx-from-context [] path0 ctx0)}))))))
      ((val . args)
       (make-call path0 ctx0 val args))
      (_
       (erlang/throw {:invalid-fn-form (idx-from-context [] path0 ctx0)})))))

(defspec comp-spec-expr ((path) (context) (erlang/term))
  {(context) (erlang/term)})

(defn default-type ()
  [{:--fun :erlang :any}])

(defn make-spec-tuple (line path0 ctx0 form)
  (case (lists/foldl (fn (el acc0)
                         (case acc0
                           ({path1 ctx1 acc1}
                            (case (comp-spec-expr path1 ctx1 el)
                              ({ctx2 comp-el}
                               {(incr-path path1) ctx2 (comp-el . acc1)})))))
                     {path0 ctx0 []} (erlang/tuple_to_list form))
    ({_ ctx3 tuple-values}
     {ctx3 {:tuple line (erlang/list_to_tuple (lists/reverse tuple-values))}})))

(defn comp-spec-args (line ctx0 args)
  (case (lists/foldl (fn (el acc0)
                         (case acc0
                           ({ctx1 acc1}
                            {(add-type-reference-to-scope-ctx el -1 ctx1)
                             ({:var line el} . acc1)})))
                     {ctx0 []} args)
    ({ctx3 comp-args}
     {ctx3 (lists/reverse comp-args)})))


(defn def-anon-function-spec (path0 ctx0 args0 expr0)
  (let (line1 (case (idx-from-context [] path0 ctx0)
                ({line0 _}
                 line0)))

    (case (comp-spec-args path0 (push-type-scope-ctx ctx0) args0)
      ({ctx3 args1}
       (case (comp-spec-expr (incr-path 2 path0) ctx3 expr0)
         ({ctx4 expr1}
          {(pop-type-scope-ctx ctx4) [{:type line1 :fun
                                             [{:type line1 :product (lists/reverse args1)}
                                              expr1]}]}))))))

(defn comp-binary-spec (line1 path0 ctx0 form)
  (case form
    ([:binary]
     {ctx0 {:type line1 :binary [{:integer line1 0} {:integer line1 0}]}})
    ([:binary arg]
     (when (erlang/is_integer arg))
     {ctx0 {:type line1 :binary [{:integer line1 arg} {:integer line1 0}]}})
    ([:binary :* arg]
     (when (erlang/is_integer arg))
     {ctx0 {:type line1 :binary [{:integer line1 0} {:integer line1 arg}]}})
    ([:binary arg1 :* arg2]
     (when (erlang/and (erlang/is_integer arg1)
                       (erlang/is_integer arg2)))
     {ctx0 {:type line1 :binary [{:integer line1 arg1} {:integer line1 arg2}]}})
    (_
     (let (idx (idx-from-context [] path0 ctx0))
       (erlang/throw {:invalid-binary-type-spec idx})))))

(defn comp-function-spec (line1 path0 ctx0 form)
  (case form
    ([:fn]
     {ctx0 {:type line1 :fun []}})
    ([:fn [:...] expr]
     (case (comp-expr (traverse-incr-path 2 path0) ctx0 expr)
       ({ctx1 comp-expr}
        {ctx1 {:type line1 :fun [{:type line1 :any} comp-expr]}})))
    ([:fn args expr]
     (def-anon-function-spec (incr-path path0) ctx0 args expr))))

(defn comp-type-call-spec (line path0 ctx0 form)
  (case form
    ([{:--fun :erlang :range} a1 a2]
     (when (erlang/and (erlang/is_integer a1)
                       (erlang/is_integer a2)))
     (case (comp-spec-args (incr-path path0) ctx0 [a1 a2])
       ({ctx1 comp-args}
        {ctx1 {:type line :range
                     comp-args}})))
    (({:--fun :erlang func} . args)
     ;; Things in erlang get treated a bit differently then things in
     ;; other modules. It sucks that they have to be special
     (case (comp-spec-args (incr-path path0) ctx0 args)
       ({ctx3 comp-args}
        {ctx3 {:type line func comp-args}})))
    (({:--fun module func} . args)
     (when (erlang/and (erlang/is_atom module)
                       (erlang/is_atom func)))
     (case (comp-spec-args (incr-path path0) ctx0 args)
       ({ctx3 comp-args}
        {ctx3 {:remote_type line [{:atom line module}
                                  {:atom line func}
                                  comp-args]}})))))

(defn make-spec-literal (path0 ctx0 arg0)
  (let (line1 (case (idx-from-context [] path0 ctx0)
                ({line0 _}
                 line0)))
    (case arg0
      (arg1
       (when (erlang/is_atom arg1))
       {:atom line1 arg1})
      (arg1
       (when (erlang/is_integer arg1))
       {:integer line1 arg1})
      ([args]
       {:list line1 (make-spec-literal (traverse-path path0) ctx0 args)})
      (arg1
       (when (erlang/is_list arg1))
       (let (specs (lists/foldl (fn (el acc0)
                                    (case acc0
                                      ({path1 acc1}
                                       {(incr-path path1)
                                        ((make-spec-literal path1 ctx0 el) .  acc1)})))
                                {path0 []} arg1))
         {:list line1 (lists/reverse specs)}))
      (arg1
       (when (erlang/is_tuple arg1))
       (let (specs (lists/foldl (fn (el acc0)
                                    (case acc0
                                      ({path1 acc1}
                                       {(incr-path path1)
                                        ((make-spec-literal path1 ctx0 el) .  acc1)})))
                                {path0 []} (erlang/tuple_to_list arg1)))
         {:tuple line1 (lists/reverse specs)}))
      (_
       (let (idx (idx-from-context [] path0 ctx0))
         (erlang/throw {:invalid-type-literal idx}))))))

(defn comp-spec-expr (path0 ctx0 form)
  (let (line1 (case (idx-from-context [] path0 ctx0)
                ({line0 _}
                 line0)))
    (case form
      ([:quote value]
       {ctx0 (make-spec-literal (traverse-incr-path path0) ctx0 value)})
      (arg
       (when (erlang/is_tuple arg))
       (make-spec-tuple line1 path0 ctx0 form))
      (arg
       (when (erlang/is_integer arg))
       {ctx0 (make-spec-literal path0 ctx0 arg)})
      ((:binary . _)
       (comp-binary-spec line1 path0 ctx0 form))
      ((:fn . _)
       (comp-function-spec line1 path0 ctx0 form))
      (({:--fun _ _} . _)
       (comp-type-call-spec line1 path0 ctx0 form))
      ([:list arg]
       (case (comp-spec-expr (traverse-incr-path path0) ctx0 arg)
         ({ctx1 list}
          {ctx1 {:list line1 list}})))
      (name
       (when (erlang/is_atom name))
       (case (resolve-type-reference-ctx name -1 ctx0)
         (:true
          {ctx0 {:var line1 name}})
         (:false
          (let (idx (idx-from-context []  path0 ctx0))
            (erlang/throw {:invalid-type-reference name idx})))))
      ((var . args)
       (let (arg-count (erlang/length args))
         (case (resolve-type-reference-ctx var arg-count ctx0)
           (:false
            (let (idx (idx-from-context [] path0 ctx0))
              (erlang/throw {:invalid-type-reference var idx})))
           (:true
            (case (comp-spec-args (incr-path path0) ctx0 args)
              ({ctx3 comp-args}
               {ctx3 {:type line1 var comp-args}}))))))
      (_
       (let (idx (idx-from-context [] path0 ctx0))
         (erlang/throw {:invalid-type-reference idx}))))))

(defn rewrite-spec-args (args acc)
  (case args
    ((:&rest . arg)
     (lists/reverse  ([arg] . acc)))
    ([]
     (lists/reverse acc))
    ((arg . rest)
     (rewrite-spec-args rest (arg . acc)))))

(defn comp-implicit-spec (path0 ctx0 name args expr)
  (let (annots (annots-from-context [] path0 ctx0)
        arity (erlang/length args)
        is-rest (lists/member :&rest args)
        new-args (case is-rest
                   (:true
                    (rewrite-spec-args args []))
                   (:false
                    args))
        ctx1 (case is-rest
               (:true
                (add-rest-ctx name (erlang/length new-args) ctx0))
               (:false ctx0)))

    (case (def-anon-function-spec (incr-path 2 path0) ctx1 args expr)
      ({ctx2 body}
       (add-type-ctx name arity {{:c_literal annots :spec}
                                 {:c_literal annots [{{name arity}
                                                      [body]}]}} ctx2)))))

(defn def-top-level-function-spec (path0 ctx0 name args expression)
  (let (line1 (case (idx-from-context [] path0 ctx0)
                ({line0 _}
                 line0))
              arity (erlang/length args)
              ctx1 (push-type-scope-ctx ctx0)
              ctx2 (add-type-reference-to-scope-ctx name arity ctx1)
              ctx4 (lists/foldl (fn (arg0 ctx3)
                                    (case arg0
                                      (arg1 (when (erlang/is_atom arg1))
                                            (add-type-reference-to-scope-ctx
                                             arg1 -1 ctx3))
                                      (_
                                       (let (idx (idx-from-context [] path0 ctx3))
                                         (erlang/throw {:invalid-type-definition
                                                        idx})))))
                                ctx2 args))
    (case (comp-spec-expr (incr-path 3 path0) ctx4 expression)
      ({ctx5 expr}
       (add-type-ctx name arity {{:c_literal [line1] :type}
                                 {:c_literal [line1]
                                             [{name expr
                                                    (lists/map
                                                     (fn (el)
                                                         {:var line1 el})
                                                     args)}]}}
                     (pop-type-scope-ctx ctx5))))))

(defn comp-spec (path0 ctx0 form)
  (case form
    ([:deftype+ name args expression]
     (when (erlang/and (erlang/is_atom name)
                       (erlang/is_list args)))
     (let (arity (erlang/length args)
           ctx1 (add-type-export-ctx name arity ctx0))
       (def-top-level-function-spec (incr-path path0) ctx0 name args expression)))
    ([:deftype name args expression]
     (when (erlang/and (erlang/is_atom name)
                       (erlang/is_list args)))
     (comp-implicit-spec (incr-path path0) ctx0 name args expression))
    ([:defspec name args expression]
     (comp-implicit-spec (incr-path path0) ctx0 name args expression))
    (_
     (let (idx (idx-from-context [] path0 ctx0))
       (erlang/throw {:invalid-type-definition idx})))))

(defn comp-function1 (path0 ctx0 return-type name args expressions)
  (let (spec-args (lists/map (fn (arg)
                                 (case arg
                                   ([spec-arg _]
                                    spec-arg)
                                   (_
                                    (default-type)))) args)
        ctx1 (comp-implicit-spec path0 ctx0 name spec-args return-type))
    (case (do-function-body (incr-path path0) ctx1 :false name args expressions)
      ({ctx2 arg-list body}
       {ctx2 name arg-list body}))))

(defn comp-function (path0 ctx0 form)
  (case form
    ((return-type . (name . (args . expressions)))
     (when (erlang/and (erlang/is_atom name)
                       (erlang/is_list args)))
     (comp-function1 (incr-path path0) ctx0 return-type name args expressions))
    ((name . (args . expressions))
     (when (and (erlang/is_list args)
                (erlang/is_atom name)))
     (comp-function1 path0 ctx0 (default-type) name args expressions))
    (_
     (erlang/throw {:invalid-definition (idx-from-context [] path0 ctx0)}))))

(defn+ comp-definition (path0 ctx0 form)
  (let (annots (annots-from-context :traverse  path0 ctx0))
    (case form
      ((:defn+ . details)
       (case (comp-function (incr-path path0) ctx0 details)
         ({ctx1 name arg-list body}
          (add-exported-def-ctx annots name arg-list body ctx1))))
      ((:defn . details)
       (case (comp-function (incr-path path0) ctx0 details)
         ({ctx1 name arg-list body}
          (add-def-ctx annots name arg-list body ctx1))))
      ((:definline . details)
       (let (inline-annots (:inline . annots))
         (case (comp-function (incr-path path0) ctx0 details)
           ({ctx1 name arg-list body}
            (add-def-ctx annots name arg-list body ctx1)))))
      ((:deftype+ . _)
       (comp-spec path0 ctx0 form))
      ((:deftype . _)
       (comp-spec path0 ctx0 form))
      ((:defspec . _)
       (comp-spec path0 ctx0 form))
      (_
       (let (idx (idx-from-context [] path0 ctx0))
         (erlang/throw {:invalid-definition idx}))))))


(defn make-literal-list (path0 annots ctx0 list)
  (case list
    ([] (cerl/c_nil))
    ((h . t)
     (cerl/ann_c_cons annots
                      (make-literal (traverse-path path0) ctx0 h)
                      (make-literal-list (incr-path path0) annots ctx0 t)))))

(defn make-literal-tuple (path0 annots ctx0 elements0)
  (let (result (lists/foldl (fn (element acc)
                                (case acc
                                  ({path1 acc0}
                                   (let (acc1 ((make-literal (traverse-path path1) ctx0 element) .  acc0)
                                         path2 (incr-path path1))
                                     {path2 acc1}))))
                            {path0 []} elements0))
    (case result
      ({_ elements1}
       (cerl/ann_c_tuple annots elements1)))))

(defn make-literal (path0 ctx0 arg0)
  (let (annots  (annots-from-context [] path0 ctx0))
    (case arg0
      (arg1
       (when (erlang/is_binary arg1))
       (cerl/ann_make_data annots {:atomic arg1} []))
      (arg1
       (when (erlang/is_atom arg1))
       (cerl/ann_c_atom annots arg1))
      (arg1
       (when (erlang/is_tuple arg1))
       (make-literal-tuple path0 annots ctx0 arg1))
      (arg1
       (when (erlang/is_integer arg1))
       (cerl/ann_c_int annots arg1))
      (arg1
       (when (erlang/is_float arg1))
       (cerl/ann_c_float annots arg1))
      ([:string str1]
       (make-literal-string (traverse-incr-path path0) annots ctx0 str1))
      (arg1
       (when (erlang/is_list arg1))
       (make-literal-list path0 annots ctx0 arg1)))))

;; Compilation Infrastructure
(defn usage (os-list)
  (getopt/usage os-list "" "[option1 option2 ...] <joxa-file>"
                '()))
(defn+ option-spec-list ()
  [{:ast \a "ast" {:boolean :false} "compile to core ast"}
   {:to-core \c "to-core" {:boolean :false} "compile to core erlang"}
   {:outdir \o "outdir" {:string "./"} "the directory to output beam files"}
   {:bootstrap \b "bootstrap" {:boolean :false}
               "Use the special limited bootstrap compiler"}])

(defn+ comp-forms (path0 ctx0 form0)
  (case form0
    ((:do . rest)
     (case  (lists/foldl (fn (form1 acc)
                             (case acc
                               ({path1 ctx1}
                                {(incr-path path1)
                                 (comp-forms path1 ctx1 form1)})))
                         {(traverse-incr-path  path0) ctx0} rest)
       ({_ ctx2}
        ctx2)))
    ((:module . _)
     (comp-module path0 ctx0 form0))
    (_
     (comp-definition path0 ctx0 form0))))

(defn erl-comp (ctx0 cerl-ast type)
  (case type
    (:final
     (case (lists/member :to_core (get-context :options ctx0))
       (:true
        [(core_pp/format cerl-ast) \\n])
       (:false
        (case (lists/member :to_ast (get-context :options ctx0))
          (:true
           (io_lib/format "~p" [cerl-ast]))
          (_
           (case (compile/forms cerl-ast
                                (lists/append (get-context :options ctx0)
                                              [:from_core
                                               :binary
                                               :return_errors
                                               :return_warnings]))
             ({ok [] result []}
              result)
             (error
              (erlang/throw error))))))))
    (_
     (case (compile/forms cerl-ast [:debug_info
                                    :from_core
                                    :return_errors
                                    :return_warnings
                                    :binary])
       ({ok [] result []}
        result)
       (error
        (erlang/throw error))))))

(defn get-context-exports (ctx0)
  (lists/map (fn (el)
                 (case el
                   ({fun arity annots}
                    (cerl/ann_c_fname annots fun arity))))
             (sets/to_list (get-context :exports ctx0))))

(defn get-definitions (ctx0)
  (lists/map (fn (el)
                 (case el
                   ({_ value}
                    value)))
             (get-context :definitions ctx0)))

;; ### make-joxa-info-1 Function Set
;;
;; The make-joxa-info-1 set of functions creates a module level
;; function that returns information sigficant to the joxa compilation
;; system for each function. This set of functions builds a function,
;; that if written in normal joxa would look like.
;;
;;    (defn __joxa_info (type)
;;        (case type
;;              (:rest
;;                   <rest-info>...)
;;              (:macro
;;                   <macro-info>...)))
;;
;; more may be added to this over time.
;; at the moment the <rest-info> looks as follows
;;
;; [{<fun-id> <restish-arity>}]
;;
;; Where <fun-id> is either the name of the function if it is a named
;; module level function. Or the tuple {:anon index} in the case of an
;; anonymous function where the index is the index of the fun in the
;; modules function table.
;;
;; macros follow a similar senario with the exception that there are
;; currently no anonymous macros. so macros are defined by function
;; name and return :true or :false depending on if the function is a
;; macro.
;;
(defn make-joxa-info-rest-1 (ctx0)
  (let (annots [:compiler_generated]
        rests (get-context :rests ctx0))
    (cerl/ann_c_clause [:compiler_generated]
                       [(cerl/ann_c_atom annots :rest)]
                       (cerl/ann_c_atom annots :true)
                       (cerl/ann_make_data annots
                                           {:atomic rests} []))))

(defn make-joxa-info-1 (ctx0)
  (let (annots [:compiler_generated]
        clauses [(make-joxa-info-rest-1 ctx0)]
        detail-var (gensym)
        var-name (cerl/c_var detail-var))
    (add-exported-def-ctx annots :--joxa-info
                          [var-name]
                          (cerl/ann_c_case annots
                                           var-name
                                           clauses)
                          ctx0
                          :replace)))

;; ### make-joxa-info-2 function set.
;;
;; The make-joxa-info-2 functions are similar to the
;; make-joxa-info-1. However, they also take a function id as well as
;; the type. this allows you to get information about a specific
;; function. if written in normal joxa would look like.
;;
;;    (defn __joxa_info (type fun-id)
;;        (case type
;;              (:rest
;;                 (case fun-id
;;                     <fun-clauses>...))
;;              (:macro
;;                 (case fun-id
;;                     <macro-clauses>...))
;;
;; more may be added to this over time.
;;
;; In this case the fun and macro clauses provide the same information
;; as the single arg __joxa_info function, however just for the
;; function specifid.
;;
(defn make-joxa-info-rest-2 (fun-var ctx0)
  (let (annots [:compiler_generated]
        rests (get-context :rests ctx0)
        catch-all-var (cerl/ann_c_var [:compiler_generated] (gensym)))
    (cerl/ann_c_case annots
                     fun-var
                     (lists/append
                      (lists/map (fn (rest-el)
                                     (case rest-el
                                       ({fun-id, value}
                                        (cerl/ann_c_clause annots
                                                           [(cerl/ann_make_data annots
                                                                                {:atomic fun-id} [])]
                                                           (cerl/ann_c_atom annots :true)
                                                           (cerl/ann_make_data annots
                                                                               {:atomic value} [])))))
                                 rests)
                      [(cerl/ann_c_clause annots
                                         [catch-all-var]
                                         (cerl/ann_c_atom annots :true)
                                         (cerl/ann_c_atom annots :false))]))))

(defn make-joxa-info-2 (ctx0)
  (let (annots [:compiler_generated]
        type-var (cerl/c_var (gensym))
        fun-id-var (cerl/c_var (gensym))
        rest-clause (cerl/ann_c_clause annots
                                       [(cerl/ann_c_atom annots :rest)]
                                       (cerl/ann_c_atom annots :true)
                                       (make-joxa-info-rest-2 fun-id-var ctx0))

        clauses [rest-clause])
    (add-exported-def-ctx [:compiler_generated] :--joxa-info
                          [type-var fun-id-var]
                          (cerl/ann_c_case [:compiler_generated]
                                           type-var
                                           clauses)
                          ctx0
                          :replace)))

(defn make-joxa-info (ctx0)
  (make-joxa-info-2
   (make-joxa-info-1 ctx0)))

(defn comp-module-info (ctx0)
  (let (module-name (cerl/c_atom (get-context :module-name ctx0))
        argless-body (cerl/c_call (cerl/c_atom :erlang)
                                  (cerl/c_atom :get_module_info)
                                  [module-name])
        ctx1 (add-exported-def-ctx [:compiler_generated] :module_info []
                                   argless-body ctx0
                                   :replace)
        detail-var (gensym)
        var-name (cerl/c_var detail-var)
        arg-body (cerl/c_call (cerl/c_atom :erlang)
                              (cerl/c_atom :get_module_info)
                              [module-name var-name]))
    (add-exported-def-ctx [:compiler_generated] :module_info
                          [var-name] arg-body ctx1 :replace)))

(defn compile-types (ctx0)
  (let (exported-types (sets/to_list (get-context :type-exports ctx0))
        all-types (ec_dictionary/to_list (get-context :types ctx0)))
    ({(cerl/c_atom :export_type) (cerl/make_data {:atomic exported-types} [])} .
     (lists/map (fn (el)
                    (case el
                      ({_ attr}
                       attr))) all-types))))


(defn sort-fun-deps (dep state)
  (case state
    ({unresolved0 resolved0}
     (case (sets/is_element dep resolved0)
       (:true
        state)
       (:false
        {(sets/add_element dep unresolved0) resolved0})))))

(defn compilable? (ctx0)
  (let (reqs (get-definitions ctx0)
             result (lists/foldl (fn (el acc)
                                     (case el
                                       ({var _ deps}
                                        (case acc
                                          ({unresolved0 resolved0}
                                           (let (element {(cerl/fname_id var) (cerl/fname_arity var)}
                                                         resolved1 (sets/add_element element resolved0)
                                                         unresolved1 (sets/del_element element unresolved0))
                                             (lists/foldl sort-fun-deps/2 {unresolved1 resolved1} (sets/to_list deps))))))))
                                 {(sets/new) (sets/new)} reqs))
    (case result
      ({unresolved _}
       (erlang/== (sets/size unresolved) 0)))))

(defn+ compile-context (ctx0 compile-type)
  (case (compilable? ctx0)
    (:true
     (let (ctx1 (make-joxa-info (comp-module-info ctx0))
                annots (get-context :line ctx1)
                module-name (cerl/ann_c_atom annots
                                             (get-context :module-name ctx1))
                exports (get-context-exports ctx1)
                attrs (lists/append (get-context :attrs ctx1)
                                    (compile-types ctx1))
                defs (lists/map (fn (def)
                                    (case def
                                      ({var body _}
                                       {var body})
                                      (else
                                       (erlang/throw else))))
                                (get-definitions ctx1)))
       {ctx1 (erl-comp ctx0 (cerl/ann_c_module annots module-name exports attrs defs)
                       compile-type)}))
    (:false
     (when (erlang/== compile-type :final))
     (erlang/throw :unresolved-function-dependencies))
    (:false
     {ctx0 :uncompilable})))

(defn parse-all (file-name input acc)
  (case (has-more-data-to-parse input)
    (:false
     (case input
       ({:parse-output _ _ annots _}
        {annots  (lists/reverse acc)})))
    (:true
     (case (parse file-name input)
       ({annots ast0 rest}
        (parse-all file-name rest (ast0 . acc)))))))

(defn convert-options (options acc)
  (case options
    (({:to-core :true} . tail)
     (convert-options tail (:to_core . acc)))
    (({:ast :true} . tail)
     (convert-options tail (:to_ast . acc)))
    (({:debug-info :true} . tail)
     (convert-options tail (:debug_info . acc)))
    ([]
     acc)
    ((_ . tail)
     (convert-options tail acc))))

(defn bootstrap-comp (file-name options binary)
  (let (comp-result
        (case (parse-all file-name binary [])
          ({annots ast}
           (lists/foldl (fn (def acc)
                            (case acc
                              ({path ctx0}
                               (let (ctx1 (comp-forms (traverse-path path)
                                                      ctx0 def))
                                 {(incr-path path) ctx1}))))
                        {(new-path) (new-context [{:options (convert-options options [])}
                                                  {:annots annots}])} ast))))
    (case comp-result
      ({_ ctx2}
       (compile-context ctx2 :intermediate)))))

(defn+ bootstrap-comp (file-name options)
  (case (file/read_file file-name)
    ({:ok binary}
     (let (result (bootstrap-comp file-name options binary))
       (case result
         ({ctx0 :uncompilable}
          (erlang/throw :unresolved-function-dependencies))
         ({ctx0 module-binary}
          (let (module-name (get-context :module-name ctx0)
                            load-result (code/load_binary module-name file-name module-binary))
            (case load-result
              ({:module module-name}
               (compile-context ctx0 :final))
              (_
               (erlang/throw {:unable-to-load file-name}))))))))
    ({:error reason}
     (erlang/throw {:file-access reason file-name}))))

(defn compile-form (file-name input ctx0 binary)
  (case (has-more-data-to-parse input)
    (:false
     (compile-context ctx0 :final))
    (:true
     (case (parse file-name input)
       ({annots ast0 (= rest {:parse-output _ path _ _})}
        (let (ctx1  (comp-forms (traverse-path path)
                                (set-context :annots annots ctx0)
                                ast0))
          (case (compile-context ctx1 :intermediate)
            ((= ref {ctx2 :uncompilable})
             (compile-form file-name rest ctx2 :uncompilable))
            ({ctx2 binary1}
             (let (module-name (get-context :module-name ctx2))
               (case (code/load_binary module-name file-name binary1)
                 ({:module module-name}
                  (compile-form file-name rest ctx2 binary1))))))))))))

(defn+ forms (file-name binary options)
  (compile-form file-name binary
                (new-context [{:options (convert-options options [])}]) <<>>))

(defn get-extension (options)
  (case (proplists/get_value :ast options)
    (:false
     (case (proplists/get_value :to-core options)
       (:false
        ".beam")
       (_
        ".core")))
    (_
     ".ast")))

(defn save-output (options binary ctx)
  (let (out-dir (proplists/get_value :outdir options :undefined))
    (case out-dir
      (:undefined
       ctx)
      (out-dir
       (let (module-name (get-context :module-name ctx)
             path (re/split (erlang/atom_to_list  module-name) "\\.")
             out-path (filename/join (out-dir . path))
             out-file (lists/flatten ((erlang/binary_to_list out-path)
                                      . (get-extension options))))
         (filelib/ensure_dir out-path)
         (file/write_file out-file binary))))))

(defn+ do-compile (file-name options)
  (let (result
        (case (proplists/get_value :bootstrap options :false)
          (:true
           (bootstrap-comp file-name options))
          (:false
           (case (file/read_file file-name)
             ({:ok binary}
              (forms file-name binary options))
             ({:error reason}
              (erlang/throw {:file-access reason file-name}))))))
    (case result
      ({ctx binary}
       (save-output options binary ctx)))))

(defn+ main (args)
  (case
      (getopt/parse (option-spec-list) args)
    ({:ok {options [target]}}
     (do-compile target options))
    (_
     (usage (option-spec-list))
     :did-not-get-it)))

(defn+ main ()
  (main (init/get_plain_arguments)))
